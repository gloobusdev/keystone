webpackJsonp([7],{

/***/ 723:
/*!*********************************************************************************!*\
  !*** ./~/babel-loader?{"cacheDirectory":true}!./fields/types/html/HtmlField.js ***!
  \*********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _Field = __webpack_require__(/*! ../Field */ 19);\n\nvar _Field2 = _interopRequireDefault(_Field);\n\nvar _react = __webpack_require__(/*! react */ 1);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _elemental = __webpack_require__(/*! elemental */ 3);\n\nvar _scriptjs = __webpack_require__(/*! scriptjs */ 1527);\n\nvar _scriptjs2 = _interopRequireDefault(_scriptjs);\n\nvar _reactTinymceInput = __webpack_require__(/*! react-tinymce-input */ 1359);\n\nvar _reactTinymceInput2 = _interopRequireDefault(_reactTinymceInput);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar editorLoaded = !!global.tinymce;\n\nmodule.exports = _Field2.default.create({\n\n\tdisplayName: 'HtmlField',\n\tstatics: {\n\t\ttype: 'Html'\n\t},\n\n\tgetInitialState: function getInitialState() {\n\t\treturn {\n\t\t\tisFocused: false,\n\t\t\teditorLoaded: editorLoaded\n\t\t};\n\t},\n\tcomponentWillMount: function componentWillMount() {\n\t\tthis.tinymceConfig = this.getOptions();\n\t},\n\tcomponentDidMount: function componentDidMount() {\n\t\tif (this.props.wysiwyg && !this.state.editorLoaded) {\n\t\t\tthis.loadEditor();\n\t\t}\n\t},\n\tloadEditor: function loadEditor() {\n\t\tvar _this = this;\n\n\t\t(0, _scriptjs2.default)(Keystone.adminPath + '/lib/tinymce/tinymce.min.js', function () {\n\t\t\t_this.setState({ editorLoaded: true });\n\t\t});\n\t},\n\thandleFocus: function handleFocus() {\n\t\tthis.setState({ isFocused: true });\n\t},\n\thandleBlur: function handleBlur() {\n\t\tthis.setState({ isFocused: false });\n\t},\n\thandleChange: function handleChange(value) {\n\t\tvar _props = this.props,\n\t\t    onChange = _props.onChange,\n\t\t    path = _props.path;\n\n\t\tonChange({ path: path, value: value });\n\t},\n\n\n\t// TODO this doesn't seem very logical, especially overrideToolbar\n\tgetOptions: function getOptions() {\n\t\tvar plugins = ['code', 'link'];\n\t\tvar options = _extends({}, Keystone.wysiwyg.options, this.props.wysiwyg);\n\t\tvar toolbar = options.overrideToolbar ? '' : 'bold italic | alignleft aligncenter alignright | bullist numlist | outdent indent | removeformat | link ';\n\n\t\tif (options.enableImages) {\n\t\t\tplugins.push('image');\n\t\t\ttoolbar += ' | image';\n\t\t}\n\n\t\tif (options.enableCloudinaryUploads || options.enableS3Uploads) {\n\t\t\tplugins.push('uploadimage');\n\t\t\ttoolbar += options.enableImages ? ' uploadimage' : ' | uploadimage';\n\t\t}\n\n\t\tif (options.additionalButtons) {\n\t\t\ttoolbar = toolbar + ' | ' + options.additionalButtons.split(',').join(' | ');\n\t\t}\n\t\tif (options.additionalPlugins) {\n\t\t\tplugins.push.apply(options.additionalPlugins.split(','));\n\t\t}\n\t\tif (options.importcss) {\n\t\t\tplugins.push('importcss');\n\t\t\tvar importcssOptions = {\n\t\t\t\tcontent_css: options.importcss,\n\t\t\t\timportcss_append: true,\n\t\t\t\timportcss_merge_classes: true\n\t\t\t};\n\n\t\t\t_extends(options.additionalOptions, importcssOptions);\n\t\t}\n\n\t\tif (!options.overrideToolbar) {\n\t\t\ttoolbar += ' | code';\n\t\t}\n\n\t\tvar opts = {\n\t\t\ttoolbar: toolbar,\n\t\t\tplugins: plugins,\n\t\t\tmenubar: options.menubar || false,\n\t\t\tskin: options.skin || 'keystone'\n\t\t};\n\n\t\tif (this.shouldRenderField()) {\n\t\t\topts.uploadimage_form_url = options.enableS3Uploads ? Keystone.adminPath + '/api/s3/upload' : Keystone.adminPath + '/api/cloudinary/upload';\n\t\t} else {\n\t\t\t_extends(opts, {\n\t\t\t\tmode: 'textareas',\n\t\t\t\treadonly: true,\n\t\t\t\tmenubar: false,\n\t\t\t\ttoolbar: 'code',\n\t\t\t\tstatusbar: false\n\t\t\t});\n\t\t}\n\n\t\tif (options.additionalOptions) {\n\t\t\t_extends(opts, options.additionalOptions);\n\t\t}\n\n\t\treturn opts;\n\t},\n\trenderField: function renderField() {\n\t\tvar _this2 = this;\n\n\t\tvar _props2 = this.props,\n\t\t    height = _props2.height,\n\t\t    value = _props2.value,\n\t\t    path = _props2.path,\n\t\t    wysiwyg = _props2.wysiwyg;\n\t\tvar _state = this.state,\n\t\t    isFocused = _state.isFocused,\n\t\t    editorLoaded = _state.editorLoaded;\n\t\tvar tinymceConfig = this.tinymceConfig;\n\n\t\tvar className = isFocused ? 'is-focused' : '';\n\t\tvar fieldClassName = wysiwyg ? 'wysiwyg' : 'code';\n\t\tvar name = this.getInputName(path);\n\t\tvar style = { minHeight: height };\n\t\tvar showEditor = wysiwyg && editorLoaded;\n\t\treturn _react2.default.createElement(\n\t\t\t'div',\n\t\t\t{ className: className },\n\t\t\tshowEditor ? _react2.default.createElement(_reactTinymceInput2.default, {\n\t\t\t\tonChange: this.handleChange,\n\t\t\t\tonFocus: this.handleFocus,\n\t\t\t\tonBlur: this.handleBlur,\n\t\t\t\tclassName: fieldClassName,\n\t\t\t\tstyle: style,\n\t\t\t\ttinymceConfig: tinymceConfig,\n\t\t\t\tname: name,\n\t\t\t\tvalue: value\n\t\t\t}) : _react2.default.createElement(_elemental.FormInput, {\n\t\t\t\tmultiline: true,\n\t\t\t\tstyle: style,\n\t\t\t\tonChange: function onChange(ev) {\n\t\t\t\t\treturn _this2.handleChange(ev.target.value);\n\t\t\t\t},\n\t\t\t\tclassName: fieldClassName,\n\t\t\t\tname: name,\n\t\t\t\tvalue: value\n\t\t\t})\n\t\t);\n\t},\n\trenderValue: function renderValue() {\n\t\tvar value = this.props.value;\n\n\t\treturn _react2.default.createElement(_elemental.FormInput, { multiline: true, noedit: true, value: value });\n\t}\n});\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-loader?{\"cacheDirectory\":true}!./fields/types/html/HtmlField.js\n// module id = 723\n// module chunks = 7\n//# sourceURL=webpack:///./fields/types/html/HtmlField.js?./~/babel-loader?%7B%22cacheDirectory%22:true%7D");

/***/ },

/***/ 1359:
/*!****************************************************!*\
  !*** ./~/react-tinymce-input/dist/TinyMCEInput.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	eval("/*global tinymce */\n\n// TinyMCE semi-controlled component.\n//\n// Limitations/Notes\n// * `tinymce` be defined in the global scope.\n// * `ignoreUpdatesWhenFocused` - sometimes TinyMCE has issues with cursor placement. This component tries very\n//     hard to avoid such issues, but if the come up, this prop might help. Set it to true and the component\n//     will only update the TinyMCE editor from new props when it does not have focus.\n// * `onChange` - this is the main event you will want to handle. Note: unlike normal React onChange events,\n//     it does not use a SyntheticEvent based event. It simply passes up the changed content.\n// * events - the component listens for several events and maps them to something more React-like (ex. blur\n//     => onBlur). Any event that changes the content should trigger both the original event plus onChange.\n//     The event handler will receive the original tinymce event as a param.\n//     [init, activate, deactivate, focus, blur, hide, remove reset, show, submit]\n// * level of control - tinymce does not trigger an event on every character change. We could try binding to\n//     a keyboard event. However, we have found that, in practice, getting changes in TinyMCE time is good enoug.\n//     If you are trying to write a control that need per-character eventing, ex. a component that allows\n//     multiple editors to work on the input at the same time, tinymce may not be right for you.\n\n'use strict';\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar React = __webpack_require__(/*! react */ 1),\n    uuid = __webpack_require__(/*! uuid */ 1361);\n\nvar DIRECT_PASSTHROUGH_EVENTS = ['Activate', 'Deactivate', 'Focus', 'Hide', 'Init', 'Remove', 'Reset', 'Show', 'Submit', 'Click'];\nvar PSEUDO_HIDDEN = { position: 'absolute', left: -200, top: -200, height: 0 };\n\nvar TinyMCEInput = React.createClass({\n  displayName: 'TinyMCEInput',\n  propTypes: {\n    className: React.PropTypes.string,\n    tinymceConfig: React.PropTypes.object.isRequired,\n    name: React.PropTypes.string, // the form name for the input element\n    value: React.PropTypes.string,\n    rows: React.PropTypes.number,\n    focus: React.PropTypes.bool, // focus the tinymce element if not already focused\n    maxInitWaitTime: React.PropTypes.number, // [20000] maximum amount of time to wait, in ms, for tinymce to create an editor before giving up\n    style: React.PropTypes.object,\n    ignoreUpdatesWhenFocused: React.PropTypes.bool, // tinymce can sometimes have cursor position issues on updates, if you app does not need live updates from the backing model, then set the prop and it will only update when the editor does not have focus\n\n    pollInterval: React.PropTypes.number.isRequired, // [1000] inteval to wait between polling for changes in tinymce editor (since blur does not always work), changes are then synced if the editor is focused\n\n    // intercepted events\n    onChange: React.PropTypes.func.isRequired, // this is a controlled component, we require onChange\n    onBlur: React.PropTypes.func,\n    onSetupEditor: React.PropTypes.func,\n\n    // direct pass through events\n    onActivate: React.PropTypes.func,\n    onClick: React.PropTypes.func,\n    onDeactivate: React.PropTypes.func,\n    onFocus: React.PropTypes.func,\n    onHide: React.PropTypes.func,\n    onInit: React.PropTypes.func,\n    onRedo: React.PropTypes.func,\n    onRemove: React.PropTypes.func,\n    onReset: React.PropTypes.func,\n    onShow: React.PropTypes.func,\n    onSubmit: React.PropTypes.func,\n    onUndo: React.PropTypes.func,\n\n    textareaProps: React.PropTypes.object.isRequired, // props passed through to the textarea\n    otherEventHandlers: React.PropTypes.objectOf(React.PropTypes.func.isRequired).isRequired\n\n  },\n  getDefaultProps: function getDefaultProps() {\n    return {\n      tinymceConfig: {},\n      maxInitWaitTime: 20000,\n      pollInterval: 1000,\n      textareaProps: {},\n      otherEventHandlers: {},\n      onChange: function onChange() {}\n    };\n  },\n  getInitialState: function getInitialState() {\n    return {\n      id: uuid(),\n      value: this.props.value\n    };\n  },\n  componentDidMount: function componentDidMount() {\n    this.initStartTime = Date.now();\n    if (typeof tinymce !== 'undefined') {\n      this.initTinyMCE();\n    } else {\n      this.initTimeout = setTimeout(this.initTinyMCE, 100);\n    }\n    this.updateInterval = setInterval(this.checkForChanges, this.props.pollInterval);\n  },\n  componentDidUpdate: function componentDidUpdate() {\n    if (this.props.focus) {\n      var editor = tinymce.get(this.state.id);\n      if (editor) {\n        editor.focus();\n      }\n    }\n  },\n  componentWillUnmount: function componentWillUnmount() {\n    tinymce.remove(this.state.id);\n    clearTimeout(this.initTimeout);\n    clearInterval(this.updateInterval);\n    this.initTimeout = undefined;\n    this.initStartTime = undefined;\n  },\n  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {\n    if (nextProps.value !== this.state.value) {\n      var editor = tinymce.get(this.state.id);\n      if (editor) {\n        if (!this.props.ignoreUpdatesWhenFocused || tinymce.focusedEditor !== editor || this.isDropOverrideFlagged()) {\n          var bookmark = editor.selection.getBookmark(2, true);\n          editor.setContent(nextProps.value);\n          editor.selection.moveToBookmark(bookmark);\n        }\n      }\n      this.setState({ value: nextProps.value });\n    }\n  },\n  setupPassthroughEvents: function setupPassthroughEvents(editor) {\n    var _this = this,\n        event;\n\n    /* eslint-disable no-loop-func */\n    for (var i = 0, len = DIRECT_PASSTHROUGH_EVENTS.length; i < len; ++i) {\n      event = DIRECT_PASSTHROUGH_EVENTS[i];\n      editor.on(event.toLowerCase(), function (tinyMCEEvent) {\n        var handler = _this.props['on' + event];\n        if (typeof handler === 'function') {\n          handler(tinyMCEEvent);\n        }\n      });\n    }\n    /* eslint-enable no-loop-func */\n\n    var handlers = this.props.otherEventHandlers;\n    for (var eventName in handlers) {\n      if (handlers.hasOwnProperty(eventName)) {\n        editor.on(eventName, handlers[eventName]);\n      }\n    }\n  },\n  setupEditor: function setupEditor(editor) {\n    editor.on('change', this.onTinyMCEChange);\n    editor.on('blur', this.onTinyMCEBlur);\n    editor.on('drop', this.onTinyMCEDrop);\n    editor.on('undo', this.onTinyMCEUndo);\n    editor.on('redo', this.onTinyMCERedo);\n    this.setupPassthroughEvents(editor);\n\n    if (this.props.onSetupEditor) {\n      this.props.onSetupEditor(editor);\n    }\n\n    if (this.props.focus) {\n      editor.focus();\n    }\n    this.initTimeout = undefined;\n  },\n  createMCEContextForComponent: function createMCEContextForComponent() {\n    var tinymceConfig = Object.assign({}, this.props.tinymceConfig, {\n      selector: '#' + this.state.id,\n      setup: this.setupEditor\n    });\n    tinymce.init(tinymceConfig);\n  },\n  initTinyMCE: function initTinyMCE() {\n    var currentTime = Date.now();\n    if (!tinymce) {\n      if (currentTime - this.initStartTime > this.props.maxInitWaitTime) {\n        this.initTimeout = undefined;\n      } else {\n        this.initTimeout = setTimeout(this.initTinyMCE, 100);\n      }\n    } else {\n      this.createMCEContextForComponent();\n      this.initTimeout = undefined;\n    }\n  },\n  clearDropOverride: function clearDropOverride() {\n    this._tempDropOverride = undefined;\n    var editor = tinymce.get(this.state.id);\n    if (editor) {\n      this.syncChange(editor.getContent());\n    }\n  },\n  flagDropOverride: function flagDropOverride() {\n    this._tempDropOverride = true;\n    if (this._tempDropOverrideTimeout) {\n      clearTimeout(this.clearDropOverride);\n    }\n    this._tempDropOverrideTimeout = setTimeout(this.clearDropOverride, 250);\n  },\n  isDropOverrideFlagged: function isDropOverrideFlagged() {\n    return this._tempDropOverride;\n  },\n  syncChange: function syncChange(newValue) {\n    if (newValue !== this.state.value) {\n      if (this.props.onChange) {\n        this.props.onChange(newValue);\n      }\n      this.setState({ value: newValue });\n    }\n  },\n  triggerEventHandler: function triggerEventHandler(handler, event) {\n    if (handler) {\n      handler(event);\n    }\n  },\n  checkForChanges: function checkForChanges() {\n    var editor = tinymce.get(this.state.id);\n    if (tinymce.focusedEditor === editor) {\n      var content = editor.getContent();\n      if (content !== this.state.value) {\n        this.syncChange(content);\n      }\n    }\n  },\n  onTinyMCEChange: function onTinyMCEChange(tinyMCEEvent) {\n    this.syncChange(tinyMCEEvent.target.getContent());\n  },\n  onTinyMCEBlur: function onTinyMCEBlur(tinyMCEEvent) {\n    this.triggerEventHandler(this.props.onBlur, tinyMCEEvent);\n    if (this.props.ignoreUpdatesWhenFocused) {\n      // if we have been ignoring updates while focused (to preserve cursor position)\n      // sync them now that we no longer have focus.\n      tinyMCEEvent.target.setContent(this.state.value);\n    }\n    if (this.props.onBlur) {\n      this.props.onBlur();\n    }\n  },\n  onTinyMCEUndo: function onTinyMCEUndo(tinyMCEEvent) {\n    this.triggerEventHandler(this.props.onUndo, tinyMCEEvent);\n    this.syncChange(tinyMCEEvent.target.getContent());\n  },\n  onTinyMCERedo: function onTinyMCERedo(tinyMCEEvent) {\n    this.triggerEventHandler(this.props.onRedo, tinyMCEEvent);\n    this.syncChange(tinyMCEEvent.target.getContent());\n  },\n  onTinyMCEDrop: function onTinyMCEDrop() {\n    // We want to process updates just after a drop, even if processUpdatesWhenFocused\n    // is false. The processUpdatesWhenFocused flag exists to keep the cursor from\n    // jumping around, and we do not cares so much if the cursor jumps after dropping\n    // an image because that is a mouse event. However, ignoring updates right after a\n    // drop means that anything that relies on knowing the content has changed is\n    // won't actually know.\n    this.flagDropOverride();\n  },\n  onTextareaChange: function onTextareaChange(e) {\n    // should only be called when tinymce failed to load and we are getting changes directly in the textarea (fallback mode?)\n    this.syncChange(e.target.value);\n  },\n  render: function render() {\n    // the textarea is controlled by tinymce... and react, neither of which agree on the value\n    // solution: keep a separate input element, controlled by just react, that will actually be submitted\n    return React.createElement(\n      'div',\n      { className: this.props.className, style: this.props.style },\n      React.createElement('input', { type: 'hidden', name: this.props.name, value: this.state.value, readOnly: true }),\n      React.createElement('textarea', _extends({\n        id: this.state.id,\n        defaultValue: this.state.value,\n        onChange: this.onTextareaChange,\n        rows: this.props.rows,\n        style: PSEUDO_HIDDEN\n      }, this.props.textareaProps))\n    );\n  }\n});\n\nmodule.exports = TinyMCEInput;\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/react-tinymce-input/dist/TinyMCEInput.js\n// module id = 1359\n// module chunks = 7\n//# sourceURL=webpack:///./~/react-tinymce-input/dist/TinyMCEInput.js?");

/***/ },

/***/ 1360:
/*!*****************************************************!*\
  !*** ./~/react-tinymce-input/~/uuid/rng-browser.js ***!
  \*****************************************************/
/***/ function(module, exports) {

	eval("/* WEBPACK VAR INJECTION */(function(global) {\nvar rng;\n\nvar crypto = global.crypto || global.msCrypto; // for IE 11\nif (crypto && crypto.getRandomValues) {\n  // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto\n  // Moderately fast, high quality\n  var _rnds8 = new Uint8Array(16);\n  rng = function whatwgRNG() {\n    crypto.getRandomValues(_rnds8);\n    return _rnds8;\n  };\n}\n\nif (!rng) {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var  _rnds = new Array(16);\n  rng = function() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return _rnds;\n  };\n}\n\nmodule.exports = rng;\n\n\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/react-tinymce-input/~/uuid/rng-browser.js\n// module id = 1360\n// module chunks = 7\n//# sourceURL=webpack:///./~/react-tinymce-input/~/uuid/rng-browser.js?");

/***/ },

/***/ 1361:
/*!**********************************************!*\
  !*** ./~/react-tinymce-input/~/uuid/uuid.js ***!
  \**********************************************/
/***/ function(module, exports, __webpack_require__) {

	eval("//     uuid.js\n//\n//     Copyright (c) 2010-2012 Robert Kieffer\n//     MIT License - http://opensource.org/licenses/mit-license.php\n\n// Unique ID creation requires a high quality random # generator.  We feature\n// detect to determine the best RNG source, normalizing to a function that\n// returns 128-bits of randomness, since that's what's usually required\nvar _rng = __webpack_require__(/*! ./rng */ 1360);\n\n// Maps for number <-> hex string conversion\nvar _byteToHex = [];\nvar _hexToByte = {};\nfor (var i = 0; i < 256; i++) {\n  _byteToHex[i] = (i + 0x100).toString(16).substr(1);\n  _hexToByte[_byteToHex[i]] = i;\n}\n\n// **`parse()` - Parse a UUID into it's component bytes**\nfunction parse(s, buf, offset) {\n  var i = (buf && offset) || 0, ii = 0;\n\n  buf = buf || [];\n  s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {\n    if (ii < 16) { // Don't overflow!\n      buf[i + ii++] = _hexToByte[oct];\n    }\n  });\n\n  // Zero out remaining bytes if string was short\n  while (ii < 16) {\n    buf[i + ii++] = 0;\n  }\n\n  return buf;\n}\n\n// **`unparse()` - Convert UUID byte array (ala parse()) into a string**\nfunction unparse(buf, offset) {\n  var i = offset || 0, bth = _byteToHex;\n  return  bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\n// random #'s we need to init node and clockseq\nvar _seedBytes = _rng();\n\n// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\nvar _nodeId = [\n  _seedBytes[0] | 0x01,\n  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]\n];\n\n// Per 4.2.2, randomize (14 bit) clockseq\nvar _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\n// Previous uuid creation time\nvar _lastMSecs = 0, _lastNSecs = 0;\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  var node = options.node || _nodeId;\n  for (var n = 0; n < 6; n++) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : unparse(b);\n}\n\n// **`v4()` - Generate random UUID**\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v4(options, buf, offset) {\n  // Deprecated - 'format' argument, as supported in v1.2\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options == 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || _rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ii++) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || unparse(rnds);\n}\n\n// Export public API\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\nuuid.parse = parse;\nuuid.unparse = unparse;\n\nmodule.exports = uuid;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/react-tinymce-input/~/uuid/uuid.js\n// module id = 1361\n// module chunks = 7\n//# sourceURL=webpack:///./~/react-tinymce-input/~/uuid/uuid.js?");

/***/ },

/***/ 1527:
/*!***********************************!*\
  !*** ./~/scriptjs/dist/script.js ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n  * $script.js JS loader & dependency manager\n  * https://github.com/ded/script.js\n  * (c) Dustin Diaz 2014 | License MIT\n  */\n\n(function (name, definition) {\n  if (typeof module != 'undefined' && module.exports) module.exports = definition()\n  else if (true) !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  else this[name] = definition()\n})('$script', function () {\n  var doc = document\n    , head = doc.getElementsByTagName('head')[0]\n    , s = 'string'\n    , f = false\n    , push = 'push'\n    , readyState = 'readyState'\n    , onreadystatechange = 'onreadystatechange'\n    , list = {}\n    , ids = {}\n    , delay = {}\n    , scripts = {}\n    , scriptpath\n    , urlArgs\n\n  function every(ar, fn) {\n    for (var i = 0, j = ar.length; i < j; ++i) if (!fn(ar[i])) return f\n    return 1\n  }\n  function each(ar, fn) {\n    every(ar, function (el) {\n      return !fn(el)\n    })\n  }\n\n  function $script(paths, idOrDone, optDone) {\n    paths = paths[push] ? paths : [paths]\n    var idOrDoneIsDone = idOrDone && idOrDone.call\n      , done = idOrDoneIsDone ? idOrDone : optDone\n      , id = idOrDoneIsDone ? paths.join('') : idOrDone\n      , queue = paths.length\n    function loopFn(item) {\n      return item.call ? item() : list[item]\n    }\n    function callback() {\n      if (!--queue) {\n        list[id] = 1\n        done && done()\n        for (var dset in delay) {\n          every(dset.split('|'), loopFn) && !each(delay[dset], loopFn) && (delay[dset] = [])\n        }\n      }\n    }\n    setTimeout(function () {\n      each(paths, function loading(path, force) {\n        if (path === null) return callback()\n        \n        if (!force && !/^https?:\\/\\//.test(path) && scriptpath) {\n          path = (path.indexOf('.js') === -1) ? scriptpath + path + '.js' : scriptpath + path;\n        }\n        \n        if (scripts[path]) {\n          if (id) ids[id] = 1\n          return (scripts[path] == 2) ? callback() : setTimeout(function () { loading(path, true) }, 0)\n        }\n\n        scripts[path] = 1\n        if (id) ids[id] = 1\n        create(path, callback)\n      })\n    }, 0)\n    return $script\n  }\n\n  function create(path, fn) {\n    var el = doc.createElement('script'), loaded\n    el.onload = el.onerror = el[onreadystatechange] = function () {\n      if ((el[readyState] && !(/^c|loade/.test(el[readyState]))) || loaded) return;\n      el.onload = el[onreadystatechange] = null\n      loaded = 1\n      scripts[path] = 2\n      fn()\n    }\n    el.async = 1\n    el.src = urlArgs ? path + (path.indexOf('?') === -1 ? '?' : '&') + urlArgs : path;\n    head.insertBefore(el, head.lastChild)\n  }\n\n  $script.get = create\n\n  $script.order = function (scripts, id, done) {\n    (function callback(s) {\n      s = scripts.shift()\n      !scripts.length ? $script(s, id, done) : $script(s, callback)\n    }())\n  }\n\n  $script.path = function (p) {\n    scriptpath = p\n  }\n  $script.urlArgs = function (str) {\n    urlArgs = str;\n  }\n  $script.ready = function (deps, ready, req) {\n    deps = deps[push] ? deps : [deps]\n    var missing = [];\n    !each(deps, function (dep) {\n      list[dep] || missing[push](dep);\n    }) && every(deps, function (dep) {return list[dep]}) ?\n      ready() : !function (key) {\n      delay[key] = delay[key] || []\n      delay[key][push](ready)\n      req && req(missing)\n    }(deps.join('|'))\n    return $script\n  }\n\n  $script.done = function (idOrDone) {\n    $script([null], idOrDone)\n  }\n\n  return $script\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/scriptjs/dist/script.js\n// module id = 1527\n// module chunks = 7\n//# sourceURL=webpack:///./~/scriptjs/dist/script.js?");

/***/ }

});