webpackJsonp([8],{

/***/ 585:
/*!*************************!*\
  !*** external "jQuery" ***!
  \*************************/
/***/ function(module, exports) {

	eval("module.exports = jQuery;\n\n//////////////////\n// WEBPACK FOOTER\n// external \"jQuery\"\n// module id = 585\n// module chunks = 8\n//# sourceURL=webpack:///external_%22jQuery%22?");

/***/ },

/***/ 735:
/*!*****************************************************************************************!*\
  !*** ./~/babel-loader?{"cacheDirectory":true}!./fields/types/markdown/MarkdownField.js ***!
  \*****************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _Field = __webpack_require__(/*! ../Field */ 19);\n\nvar _Field2 = _interopRequireDefault(_Field);\n\nvar _react = __webpack_require__(/*! react */ 1);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _elemental = __webpack_require__(/*! elemental */ 3);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * TODO:\n * - Remove dependency on jQuery\n */\n\n// Scope jQuery and the bootstrap-markdown editor so it will mount\nvar $ = __webpack_require__(/*! jquery */ 585);\n__webpack_require__(/*! ./lib/bootstrap-markdown */ 737);\n\n// Append/remove ### surround the selection\n// Source: https://github.com/toopay/bootstrap-markdown/blob/master/js/bootstrap-markdown.js#L909\nvar toggleHeading = function toggleHeading(e, level) {\n\tvar chunk;\n\tvar cursor;\n\tvar selected = e.getSelection();\n\tvar content = e.getContent();\n\tvar pointer;\n\tvar prevChar;\n\n\tif (selected.length === 0) {\n\t\t// Give extra word\n\t\tchunk = e.__localize('heading text');\n\t} else {\n\t\tchunk = selected.text + '\\n';\n\t}\n\n\t// transform selection and set the cursor into chunked text\n\tif ((pointer = level.length + 1, content.substr(selected.start - pointer, pointer) === level + ' ') || (pointer = level.length, content.substr(selected.start - pointer, pointer) === level)) {\n\t\te.setSelection(selected.start - pointer, selected.end);\n\t\te.replaceSelection(chunk);\n\t\tcursor = selected.start - pointer;\n\t} else if (selected.start > 0 && (prevChar = content.substr(selected.start - 1, 1), !!prevChar && prevChar !== '\\n')) {\n\t\te.replaceSelection('\\n\\n' + level + ' ' + chunk);\n\t\tcursor = selected.start + level.length + 3;\n\t} else {\n\t\t// Empty string before element\n\t\te.replaceSelection(level + ' ' + chunk);\n\t\tcursor = selected.start + level.length + 1;\n\t}\n\n\t// Set the cursor\n\te.setSelection(cursor, cursor + chunk.length);\n};\n\nvar renderMarkdown = function renderMarkdown(component) {\n\t// dependsOn means that sometimes the component is mounted as a null, so account for that & noop\n\tif (!component.refs.markdownTextarea) {\n\t\treturn;\n\t}\n\n\tvar options = {\n\t\tautofocus: false,\n\t\tsavable: false,\n\t\tresize: 'vertical',\n\t\theight: component.props.height,\n\t\thiddenButtons: ['Heading'],\n\n\t\t// Heading buttons\n\t\tadditionalButtons: [{\n\t\t\tname: 'groupHeaders',\n\t\t\tdata: [{\n\t\t\t\tname: 'cmdH1',\n\t\t\t\ttitle: 'Heading 1',\n\t\t\t\tbtnText: 'H1',\n\t\t\t\tcallback: function callback(e) {\n\t\t\t\t\ttoggleHeading(e, '#');\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tname: 'cmdH2',\n\t\t\t\ttitle: 'Heading 2',\n\t\t\t\tbtnText: 'H2',\n\t\t\t\tcallback: function callback(e) {\n\t\t\t\t\ttoggleHeading(e, '##');\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tname: 'cmdH3',\n\t\t\t\ttitle: 'Heading 3',\n\t\t\t\tbtnText: 'H3',\n\t\t\t\tcallback: function callback(e) {\n\t\t\t\t\ttoggleHeading(e, '###');\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tname: 'cmdH4',\n\t\t\t\ttitle: 'Heading 4',\n\t\t\t\tbtnText: 'H4',\n\t\t\t\tcallback: function callback(e) {\n\t\t\t\t\ttoggleHeading(e, '####');\n\t\t\t\t}\n\t\t\t}]\n\t\t}],\n\n\t\t// Insert Header buttons into the toolbar\n\t\treorderButtonGroups: ['groupFont', 'groupHeaders', 'groupLink', 'groupMisc', 'groupUtil']\n\t};\n\n\tif (component.props.toolbarOptions.hiddenButtons) {\n\t\tvar hiddenButtons = typeof component.props.toolbarOptions.hiddenButtons === 'string' ? component.props.toolbarOptions.hiddenButtons.split(',') : component.props.toolbarOptions.hiddenButtons;\n\n\t\toptions.hiddenButtons = options.hiddenButtons.concat(hiddenButtons);\n\t}\n\n\t$(component.refs.markdownTextarea).markdown(options);\n};\n\nmodule.exports = _Field2.default.create({\n\tdisplayName: 'MarkdownField',\n\tstatics: {\n\t\ttype: 'Markdown',\n\t\tgetDefaultValue: function getDefaultValue() {\n\t\t\treturn {};\n\t\t}\n\t},\n\n\t// override `shouldCollapse` to check the markdown field correctly\n\tshouldCollapse: function shouldCollapse() {\n\t\treturn this.props.collapse && !this.props.value.md;\n\t},\n\n\n\t// only have access to `refs` once component is mounted\n\tcomponentDidMount: function componentDidMount() {\n\t\tif (this.props.wysiwyg) {\n\t\t\trenderMarkdown(this);\n\t\t}\n\t},\n\n\n\t// only have access to `refs` once component is mounted\n\tcomponentDidUpdate: function componentDidUpdate() {\n\t\tif (this.props.wysiwyg) {\n\t\t\trenderMarkdown(this);\n\t\t}\n\t},\n\trenderField: function renderField() {\n\t\tvar styles = {\n\t\t\tpadding: 8,\n\t\t\theight: this.props.height\n\t\t};\n\t\tvar defaultValue = this.props.value !== undefined && this.props.value.md !== undefined ? this.props.value.md : '';\n\n\t\treturn _react2.default.createElement('textarea', {\n\t\t\tclassName: 'md-editor__input code',\n\t\t\tdefaultValue: defaultValue,\n\t\t\tname: this.getInputName(this.props.paths.md),\n\t\t\tref: 'markdownTextarea',\n\t\t\tstyle: styles\n\t\t});\n\t},\n\trenderValue: function renderValue() {\n\t\t// TODO: victoriafrench - is this the correct way to do this? the object\n\t\t// should be creating a default md where one does not exist imo.\n\n\t\tvar innerHtml = this.props.value !== undefined && this.props.value.md !== undefined ? this.props.value.md.replace(/\\n/g, '<br />') : '';\n\n\t\treturn _react2.default.createElement(_elemental.FormInput, {\n\t\t\tdangerouslySetInnerHTML: { __html: innerHtml },\n\t\t\tmultiline: true,\n\t\t\tnoedit: true\n\t\t});\n\t}\n});\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-loader?{\"cacheDirectory\":true}!./fields/types/markdown/MarkdownField.js\n// module id = 735\n// module chunks = 8\n//# sourceURL=webpack:///./fields/types/markdown/MarkdownField.js?./~/babel-loader?%7B%22cacheDirectory%22:true%7D");

/***/ },

/***/ 737:
/*!*********************************************************!*\
  !*** ./fields/types/markdown/lib/bootstrap-markdown.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/* ===================================================\n* bootstrap-markdown.js v2.7.0\n* http://github.com/toopay/bootstrap-markdown\n* ===================================================\n* Copyright 2013-2014 Taufan Aditya\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n* http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n* ========================================================== */\n\nvar $ = __webpack_require__(/*! jquery */ 585);\nvar marked = __webpack_require__(/*! marked */ 1207);\n\n/* MARKDOWN CLASS DEFINITION\n * ========================== */\n\nvar Markdown = function Markdown(element, options) {\n\t// Class Properties\n\tthis.$ns = 'bootstrap-markdown';\n\tthis.$element = $(element);\n\tthis.$editable = { el: null, type: null, attrKeys: [], attrValues: [], content: null };\n\tthis.$options = $.extend(true, {}, $.fn.markdown.defaults, options, this.$element.data(), this.$element.data('options'));\n\tthis.$oldContent = null;\n\tthis.$isPreview = false;\n\tthis.$isFullscreen = false;\n\tthis.$editor = null;\n\tthis.$textarea = null;\n\tthis.$handler = [];\n\tthis.$callback = [];\n\tthis.$nextTab = [];\n\n\tthis.showEditor();\n};\n\nMarkdown.prototype = {\n\n\tconstructor: Markdown,\n\n\t__alterButtons: function __alterButtons(name, alter) {\n\t\tvar handler = this.$handler,\n\t\t    isAll = name == 'all',\n\t\t    that = this;\n\n\t\t$.each(handler, function (k, v) {\n\t\t\tvar halt = true;\n\t\t\tif (isAll) {\n\t\t\t\thalt = false;\n\t\t\t} else {\n\t\t\t\thalt = v.indexOf(name) < 0;\n\t\t\t}\n\n\t\t\tif (halt == false) {\n\t\t\t\talter(that.$editor.find('button[data-handler=\"' + v + '\"]'));\n\t\t\t}\n\t\t});\n\t},\n\n\t__buildButtons: function __buildButtons(buttonsArray, container) {\n\t\tvar i,\n\t\t    ns = this.$ns,\n\t\t    handler = this.$handler,\n\t\t    callback = this.$callback;\n\n\t\tfor (i = 0; i < buttonsArray.length; i++) {\n\t\t\t// Build each group container\n\t\t\tvar y,\n\t\t\t    btnGroups = buttonsArray[i];\n\t\t\tfor (y = 0; y < btnGroups.length; y++) {\n\t\t\t\t// Build each button group\n\t\t\t\tvar z,\n\t\t\t\t    buttons = btnGroups[y].data,\n\t\t\t\t    btnGroupContainer = $('<div/>', {\n\t\t\t\t\t'class': 'md-editor__btn-group'\n\t\t\t\t});\n\n\t\t\t\tfor (z = 0; z < buttons.length; z++) {\n\t\t\t\t\tvar button = buttons[z],\n\t\t\t\t\t    buttonContainer,\n\t\t\t\t\t    buttonIconContainer,\n\t\t\t\t\t    buttonHandler = ns + '-' + button.name,\n\t\t\t\t\t    buttonIcon = this.__getIcon(button.icon),\n\t\t\t\t\t    btnText = button.btnText ? button.btnText : '',\n\t\t\t\t\t    btnClass = button.btnClass ? button.btnClass : 'md-editor__btn',\n\t\t\t\t\t    tabIndex = button.tabIndex ? button.tabIndex : '-1',\n\t\t\t\t\t    hotkey = typeof button.hotkey !== 'undefined' ? button.hotkey : '',\n\t\t\t\t\t    hotkeyCaption = typeof jQuery.hotkeys !== 'undefined' && hotkey !== '' ? ' (' + hotkey + ')' : '';\n\n\t\t\t\t\t// Construct the button object\n\t\t\t\t\tbuttonContainer = $('<button></button>');\n\t\t\t\t\tbuttonContainer.text(' ' + this.__localize(btnText)).addClass('md-editor__btn').addClass(btnClass);\n\t\t\t\t\tif (btnClass.match(/md-editor__btn\\--(primary|success|info|warning|danger|link)/)) {\n\t\t\t\t\t\tbuttonContainer.removeClass('md-editor__btn');\n\t\t\t\t\t}\n\t\t\t\t\tbuttonContainer.attr({\n\t\t\t\t\t\t'type': 'button',\n\t\t\t\t\t\t'title': this.__localize(button.title) + hotkeyCaption,\n\t\t\t\t\t\t'tabindex': tabIndex,\n\t\t\t\t\t\t'data-provider': ns,\n\t\t\t\t\t\t'data-handler': buttonHandler,\n\t\t\t\t\t\t'data-hotkey': hotkey\n\t\t\t\t\t});\n\t\t\t\t\tif (button.toggle == true) {\n\t\t\t\t\t\tbuttonContainer.attr('data-toggle', 'button');\n\t\t\t\t\t}\n\t\t\t\t\tbuttonIconContainer = $('<span/>');\n\t\t\t\t\tbuttonIconContainer.addClass(buttonIcon);\n\t\t\t\t\tbuttonIconContainer.prependTo(buttonContainer);\n\n\t\t\t\t\t// Attach the button object\n\t\t\t\t\tbtnGroupContainer.append(buttonContainer);\n\n\t\t\t\t\t// Register handler and callback\n\t\t\t\t\thandler.push(buttonHandler);\n\t\t\t\t\tcallback.push(button.callback);\n\t\t\t\t}\n\n\t\t\t\t// Attach the button group into container dom\n\t\t\t\tcontainer.append(btnGroupContainer);\n\t\t\t}\n\t\t}\n\n\t\treturn container;\n\t},\n\t__setListener: function __setListener() {\n\t\t// Set size and resizable Properties\n\t\tvar hasRows = typeof this.$textarea.attr('rows') != 'undefined',\n\t\t    maxRows = this.$textarea.val().split(\"\\n\").length > 5 ? this.$textarea.val().split(\"\\n\").length : '5',\n\t\t    rowsVal = hasRows ? this.$textarea.attr('rows') : maxRows;\n\n\t\tthis.$textarea.attr('rows', rowsVal);\n\t\tif (this.$options.resize) {\n\t\t\tthis.$textarea.css('resize', this.$options.resize);\n\t\t}\n\n\t\tthis.$textarea.on('focus', $.proxy(this.focus, this)).on('keypress', $.proxy(this.keypress, this)).on('keyup', $.proxy(this.keyup, this)).on('change', $.proxy(this.change, this));\n\n\t\tif (this.eventSupported('keydown')) {\n\t\t\tthis.$textarea.on('keydown', $.proxy(this.keydown, this));\n\t\t}\n\n\t\t// Re-attach markdown data\n\t\tthis.$textarea.data('markdown', this);\n\t},\n\n\t__handle: function __handle(e) {\n\t\tvar target = $(e.currentTarget),\n\t\t    handler = this.$handler,\n\t\t    callback = this.$callback,\n\t\t    handlerName = target.attr('data-handler'),\n\t\t    callbackIndex = handler.indexOf(handlerName),\n\t\t    callbackHandler = callback[callbackIndex];\n\n\t\t// Trigger the focusin\n\t\t$(e.currentTarget).focus();\n\n\t\tcallbackHandler(this);\n\n\t\t// Trigger onChange for each button handle\n\t\tthis.change(this);\n\n\t\t// Unless it was the save handler,\n\t\t// focusin the textarea\n\t\tif (handlerName.indexOf('cmdSave') < 0) {\n\t\t\tthis.$textarea.focus();\n\t\t}\n\n\t\te.preventDefault();\n\t},\n\n\t__localize: function __localize(string) {\n\t\tvar messages = $.fn.markdown.messages,\n\t\t    language = this.$options.language;\n\t\tif (typeof messages !== 'undefined' && typeof messages[language] !== 'undefined' && typeof messages[language][string] !== 'undefined') {\n\t\t\treturn messages[language][string];\n\t\t}\n\t\treturn string;\n\t},\n\n\t__getIcon: function __getIcon(src) {\n\t\treturn (typeof src === 'undefined' ? 'undefined' : _typeof(src)) == 'object' ? src[this.$options.iconlibrary] : src;\n\t},\n\n\tsetFullscreen: function setFullscreen(mode) {\n\t\tvar $editor = this.$editor,\n\t\t    $textarea = this.$textarea;\n\n\t\tif (mode === true) {\n\t\t\t$editor.addClass('md-fullscreen-mode');\n\t\t\t$('body').addClass('md-editor--no-overflow');\n\t\t\tthis.$options.onFullscreen(this);\n\t\t} else {\n\t\t\t$editor.removeClass('md-fullscreen-mode');\n\t\t\t$('body').removeClass('md-editor--no-overflow');\n\t\t}\n\n\t\tthis.$isFullscreen = mode;\n\t\t$textarea.focus();\n\t},\n\n\tshowEditor: function showEditor() {\n\t\tvar instance = this,\n\t\t    textarea,\n\t\t    ns = this.$ns,\n\t\t    container = this.$element,\n\t\t    originalHeigth = container.css('height'),\n\t\t    originalWidth = container.css('width'),\n\t\t    editable = this.$editable,\n\t\t    handler = this.$handler,\n\t\t    callback = this.$callback,\n\t\t    options = this.$options,\n\t\t    editor = $('<div/>', {\n\t\t\t'class': 'md-editor',\n\t\t\tclick: function click() {\n\t\t\t\tinstance.focus();\n\t\t\t}\n\t\t});\n\n\t\t// Prepare the editor\n\t\tif (this.$editor == null) {\n\t\t\t// Create the panel\n\t\t\tvar editorHeader = $('<div/>', {\n\t\t\t\t'class': 'md-editor__header btn-toolbar'\n\t\t\t});\n\n\t\t\t// Merge the main & additional button groups together\n\t\t\tvar allBtnGroups = [];\n\t\t\tif (options.buttons.length > 0) allBtnGroups = allBtnGroups.concat(options.buttons[0]);\n\t\t\tif (options.additionalButtons.length > 0) allBtnGroups = allBtnGroups.concat(options.additionalButtons[0]);\n\n\t\t\t// Reduce and/or reorder the button groups\n\t\t\tif (options.reorderButtonGroups.length > 0) {\n\t\t\t\tallBtnGroups = allBtnGroups.filter(function (btnGroup) {\n\t\t\t\t\treturn options.reorderButtonGroups.indexOf(btnGroup.name) > -1;\n\t\t\t\t}).sort(function (a, b) {\n\t\t\t\t\tif (options.reorderButtonGroups.indexOf(a.name) < options.reorderButtonGroups.indexOf(b.name)) return -1;\n\t\t\t\t\tif (options.reorderButtonGroups.indexOf(a.name) > options.reorderButtonGroups.indexOf(b.name)) return 1;\n\t\t\t\t\treturn 0;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Build the buttons\n\t\t\tif (allBtnGroups.length > 0) {\n\t\t\t\teditorHeader = this.__buildButtons([allBtnGroups], editorHeader);\n\t\t\t}\n\n\t\t\tif (options.fullscreen.enable) {\n\t\t\t\teditorHeader.append('<div class=\"md-controls\"><a class=\"md-control md-control-fullscreen\" href=\"javascript:;\" tabIndex=\"-1\"><span class=\"' + this.__getIcon(options.fullscreen.icons.fullscreenOn) + '\"></span></a></div>').on('click', '.md-control-fullscreen', function (e) {\n\t\t\t\t\te.preventDefault();\n\t\t\t\t\tinstance.setFullscreen(true);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\teditor.append(editorHeader);\n\n\t\t\t// Wrap the textarea\n\t\t\tif (container.is('textarea')) {\n\t\t\t\tcontainer.before(editor);\n\t\t\t\ttextarea = container;\n\t\t\t\ttextarea.addClass('md-input');\n\t\t\t\teditor.append(textarea);\n\t\t\t} else {\n\t\t\t\tvar rawContent = typeof toMarkdown == 'function' ? toMarkdown(container.html()) : container.html(),\n\t\t\t\t    currentContent = $.trim(rawContent);\n\n\t\t\t\t// This is some arbitrary content that could be edited\n\t\t\t\ttextarea = $('<textarea/>', {\n\t\t\t\t\t'class': 'md-input',\n\t\t\t\t\t'val': currentContent\n\t\t\t\t});\n\n\t\t\t\teditor.append(textarea);\n\n\t\t\t\t// Save the editable\n\t\t\t\teditable.el = container;\n\t\t\t\teditable.type = container.prop('tagName').toLowerCase();\n\t\t\t\teditable.content = container.html();\n\n\t\t\t\t$(container[0].attributes).each(function () {\n\t\t\t\t\teditable.attrKeys.push(this.nodeName);\n\t\t\t\t\teditable.attrValues.push(this.nodeValue);\n\t\t\t\t});\n\n\t\t\t\t// Set editor to blocked the original container\n\t\t\t\tcontainer.replaceWith(editor);\n\t\t\t}\n\n\t\t\tvar editorFooter = $('<div/>', {\n\t\t\t\t'class': 'md-footer'\n\t\t\t}),\n\t\t\t    createFooter = false,\n\t\t\t    footer = '';\n\t\t\t// Create the footer if savable\n\t\t\tif (options.savable) {\n\t\t\t\tcreateFooter = true;\n\t\t\t\tvar saveHandler = 'cmdSave';\n\n\t\t\t\t// Register handler and callback\n\t\t\t\thandler.push(saveHandler);\n\t\t\t\tcallback.push(options.onSave);\n\n\t\t\t\teditorFooter.append('<button class=\"btn btn-success\" data-provider=\"' + ns + '\" data-handler=\"' + saveHandler + '\"><i class=\"icon icon-white icon-ok\"></i> ' + this.__localize('Save') + '</button>');\n\t\t\t}\n\n\t\t\tfooter = typeof options.footer === 'function' ? options.footer(this) : options.footer;\n\n\t\t\tif ($.trim(footer) !== '') {\n\t\t\t\tcreateFooter = true;\n\t\t\t\teditorFooter.append(footer);\n\t\t\t}\n\n\t\t\tif (createFooter) editor.append(editorFooter);\n\n\t\t\t// Set width\n\t\t\tif (options.width && options.width !== 'inherit') {\n\t\t\t\tif (jQuery.isNumeric(options.width)) {\n\t\t\t\t\teditor.css('display', 'table');\n\t\t\t\t\ttextarea.css('width', options.width + 'px');\n\t\t\t\t} else {\n\t\t\t\t\teditor.addClass(options.width);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set height\n\t\t\tif (options.height && options.height !== 'inherit') {\n\t\t\t\tif (jQuery.isNumeric(options.height)) {\n\t\t\t\t\tvar height = options.height;\n\t\t\t\t\tif (editorHeader) height = Math.max(0, height - editorHeader.outerHeight());\n\t\t\t\t\tif (editorFooter) height = Math.max(0, height - editorFooter.outerHeight());\n\t\t\t\t\ttextarea.css('height', height + 'px');\n\t\t\t\t} else {\n\t\t\t\t\teditor.addClass(options.height);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Reference\n\t\t\tthis.$editor = editor;\n\t\t\tthis.$textarea = textarea;\n\t\t\tthis.$editable = editable;\n\t\t\tthis.$oldContent = this.getContent();\n\n\t\t\tthis.__setListener();\n\n\t\t\t// Set editor attributes, data short-hand API and listener\n\t\t\tthis.$editor.attr('id', new Date().getTime());\n\t\t\tthis.$editor.on('click', '[data-provider=\"bootstrap-markdown\"]', $.proxy(this.__handle, this));\n\n\t\t\tif (this.$element.is(':disabled') || this.$element.is('[readonly]')) {\n\t\t\t\tthis.$editor.addClass('md-editor-disabled');\n\t\t\t\tthis.disableButtons('all');\n\t\t\t}\n\n\t\t\tif (this.eventSupported('keydown') && _typeof(jQuery.hotkeys) === 'object') {\n\t\t\t\teditorHeader.find('[data-provider=\"bootstrap-markdown\"]').each(function () {\n\t\t\t\t\tvar $button = $(this),\n\t\t\t\t\t    hotkey = $button.attr('data-hotkey');\n\t\t\t\t\tif (hotkey.toLowerCase() !== '') {\n\t\t\t\t\t\ttextarea.bind('keydown', hotkey, function () {\n\t\t\t\t\t\t\t$button.trigger('click');\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (options.initialstate === 'preview') {\n\t\t\t\tthis.showPreview();\n\t\t\t} else if (options.initialstate === 'fullscreen' && options.fullscreen.enable) {\n\t\t\t\tthis.setFullscreen(true);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.$editor.show();\n\t\t}\n\n\t\tif (options.autofocus) {\n\t\t\tthis.$textarea.focus();\n\t\t\tthis.$editor.addClass('active');\n\t\t}\n\n\t\tif (options.fullscreen.enable && options.fullscreen !== false) {\n\t\t\tthis.$editor.append('\\\n\t\t\t\t<div class=\"md-fullscreen-controls\">\\\n\t\t\t\t\t<a href=\"#\" class=\"exit-fullscreen\" title=\"Exit fullscreen\"><span class=\"' + this.__getIcon(options.fullscreen.icons.fullscreenOff) + '\"></span></a>\\\n\t\t\t\t</div>');\n\n\t\t\tthis.$editor.on('click', '.exit-fullscreen', function (e) {\n\t\t\t\te.preventDefault();\n\t\t\t\tinstance.setFullscreen(false);\n\t\t\t});\n\t\t}\n\n\t\t// hide hidden buttons from options\n\t\tthis.hideButtons(options.hiddenButtons);\n\n\t\t// disable disabled buttons from options\n\t\tthis.disableButtons(options.disabledButtons);\n\n\t\t// Trigger the onShow hook\n\t\toptions.onShow(this);\n\n\t\treturn this;\n\t},\n\n\tparseContent: function parseContent() {\n\t\tvar content,\n\t\t    callbackContent = this.$options.onPreview(this); // Try to get the content from callback\n\n\t\tif (typeof callbackContent == 'string') {\n\t\t\t// Set the content based by callback content\n\t\t\tcontent = callbackContent;\n\t\t} else {\n\t\t\t// Set the content\n\t\t\tvar val = this.$textarea.val();\n\t\t\tif ((typeof markdown === 'undefined' ? 'undefined' : _typeof(markdown)) == 'object') {\n\t\t\t\tcontent = markdown.toHTML(val);\n\t\t\t} else if (typeof marked == 'function') {\n\t\t\t\tcontent = marked(val);\n\t\t\t} else {\n\t\t\t\tcontent = val;\n\t\t\t}\n\t\t}\n\n\t\treturn content;\n\t},\n\n\tshowPreview: function showPreview() {\n\t\tvar options = this.$options,\n\t\t    container = this.$textarea,\n\t\t    afterContainer = container.next(),\n\t\t    replacementContainer = $('<div/>', { 'class': 'md-editor__preview', 'data-provider': 'markdown-preview' }),\n\t\t    content;\n\n\t\t// Give flag that tell the editor enter preview mode\n\t\tthis.$isPreview = true;\n\t\t// Disable all buttons\n\t\tthis.disableButtons('all').enableButtons('cmdPreview');\n\n\t\tcontent = this.parseContent();\n\n\t\t// Build preview element\n\t\treplacementContainer.html(content);\n\n\t\tif (afterContainer && afterContainer.attr('class') == 'md-footer') {\n\t\t\t// If there is footer element, insert the preview container before it\n\t\t\treplacementContainer.insertBefore(afterContainer);\n\t\t} else {\n\t\t\t// Otherwise, just append it after textarea\n\t\t\tcontainer.parent().append(replacementContainer);\n\t\t}\n\n\t\t// Set the preview element dimensions\n\t\treplacementContainer.css({\n\t\t\twidth: container.outerWidth() + 'px',\n\t\t\theight: container.outerHeight() + 'px'\n\t\t});\n\n\t\tif (this.$options.resize) {\n\t\t\treplacementContainer.css('resize', this.$options.resize);\n\t\t}\n\n\t\t// Hide the last-active textarea\n\t\tcontainer.hide();\n\n\t\t// Attach the editor instances\n\t\treplacementContainer.data('markdown', this);\n\n\t\tif (this.$element.is(':disabled') || this.$element.is('[readonly]')) {\n\t\t\tthis.$editor.addClass('md-editor-disabled');\n\t\t\tthis.disableButtons('all');\n\t\t}\n\n\t\treturn this;\n\t},\n\n\thidePreview: function hidePreview() {\n\t\t// Give flag that tell the editor quit preview mode\n\t\tthis.$isPreview = false;\n\n\t\t// Obtain the preview container\n\t\tvar container = this.$editor.find('div[data-provider=\"markdown-preview\"]');\n\n\t\t// Remove the preview container\n\t\tcontainer.remove();\n\n\t\t// Enable all buttons\n\t\tthis.enableButtons('all');\n\t\t// Disable configured disabled buttons\n\t\tthis.disableButtons(this.$options.disabledButtons);\n\n\t\t// Back to the editor\n\t\tthis.$textarea.show();\n\t\tthis.__setListener();\n\n\t\treturn this;\n\t},\n\n\tisDirty: function isDirty() {\n\t\treturn this.$oldContent != this.getContent();\n\t},\n\n\tgetContent: function getContent() {\n\t\treturn this.$textarea.val();\n\t},\n\n\tsetContent: function setContent(content) {\n\t\tthis.$textarea.val(content);\n\n\t\treturn this;\n\t},\n\n\tfindSelection: function findSelection(chunk) {\n\t\tvar content = this.getContent(),\n\t\t    startChunkPosition;\n\n\t\tif (startChunkPosition = content.indexOf(chunk), startChunkPosition >= 0 && chunk.length > 0) {\n\t\t\tvar oldSelection = this.getSelection(),\n\t\t\t    selection;\n\n\t\t\tthis.setSelection(startChunkPosition, startChunkPosition + chunk.length);\n\t\t\tselection = this.getSelection();\n\n\t\t\tthis.setSelection(oldSelection.start, oldSelection.end);\n\n\t\t\treturn selection;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t},\n\n\tgetSelection: function getSelection() {\n\n\t\tvar e = this.$textarea[0];\n\n\t\treturn ('selectionStart' in e && function () {\n\t\t\tvar l = e.selectionEnd - e.selectionStart;\n\t\t\treturn { start: e.selectionStart, end: e.selectionEnd, length: l, text: e.value.substr(e.selectionStart, l) };\n\t\t} ||\n\n\t\t/* browser not supported */\n\t\tfunction () {\n\t\t\treturn null;\n\t\t})();\n\t},\n\n\tsetSelection: function setSelection(start, end) {\n\n\t\tvar e = this.$textarea[0];\n\n\t\treturn ('selectionStart' in e && function () {\n\t\t\te.selectionStart = start;\n\t\t\te.selectionEnd = end;\n\t\t\treturn;\n\t\t} ||\n\n\t\t/* browser not supported */\n\t\tfunction () {\n\t\t\treturn null;\n\t\t})();\n\t},\n\n\treplaceSelection: function replaceSelection(text) {\n\n\t\tvar e = this.$textarea[0];\n\n\t\treturn ('selectionStart' in e && function () {\n\t\t\te.value = e.value.substr(0, e.selectionStart) + text + e.value.substr(e.selectionEnd, e.value.length);\n\t\t\t// Set cursor to the last replacement end\n\t\t\te.selectionStart = e.value.length;\n\t\t\treturn this;\n\t\t} ||\n\n\t\t/* browser not supported */\n\t\tfunction () {\n\t\t\te.value += text;\n\t\t\treturn jQuery(e);\n\t\t})();\n\t},\n\n\tgetNextTab: function getNextTab() {\n\t\t// Shift the nextTab\n\t\tif (this.$nextTab.length == 0) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\tvar nextTab,\n\t\t\t    tab = this.$nextTab.shift();\n\n\t\t\tif (typeof tab == 'function') {\n\t\t\t\tnextTab = tab();\n\t\t\t} else if ((typeof tab === 'undefined' ? 'undefined' : _typeof(tab)) == 'object' && tab.length > 0) {\n\t\t\t\tnextTab = tab;\n\t\t\t}\n\n\t\t\treturn nextTab;\n\t\t}\n\t},\n\n\tsetNextTab: function setNextTab(start, end) {\n\t\t// Push new selection into nextTab collections\n\t\tif (typeof start == 'string') {\n\t\t\tvar that = this;\n\t\t\tthis.$nextTab.push(function () {\n\t\t\t\treturn that.findSelection(start);\n\t\t\t});\n\t\t} else if (typeof start == 'number' && typeof end == 'number') {\n\t\t\tvar oldSelection = this.getSelection();\n\n\t\t\tthis.setSelection(start, end);\n\t\t\tthis.$nextTab.push(this.getSelection());\n\n\t\t\tthis.setSelection(oldSelection.start, oldSelection.end);\n\t\t}\n\n\t\treturn;\n\t},\n\n\t__parseButtonNameParam: function __parseButtonNameParam(nameParam) {\n\t\tvar buttons = [];\n\n\t\tif (typeof nameParam == 'string') {\n\t\t\tbuttons.push(nameParam);\n\t\t} else {\n\t\t\tbuttons = nameParam;\n\t\t}\n\n\t\treturn buttons;\n\t},\n\n\tenableButtons: function enableButtons(name) {\n\t\tvar buttons = this.__parseButtonNameParam(name),\n\t\t    that = this;\n\n\t\t$.each(buttons, function (i, v) {\n\t\t\tthat.__alterButtons(buttons[i], function (el) {\n\t\t\t\tel.removeAttr('disabled');\n\t\t\t});\n\t\t});\n\n\t\treturn this;\n\t},\n\n\tdisableButtons: function disableButtons(name) {\n\t\tvar buttons = this.__parseButtonNameParam(name),\n\t\t    that = this;\n\n\t\t$.each(buttons, function (i, v) {\n\t\t\tthat.__alterButtons(buttons[i], function (el) {\n\t\t\t\tel.attr('disabled', 'disabled');\n\t\t\t});\n\t\t});\n\n\t\treturn this;\n\t},\n\n\thideButtons: function hideButtons(name) {\n\t\tvar buttons = this.__parseButtonNameParam(name),\n\t\t    that = this;\n\n\t\t$.each(buttons, function (i, v) {\n\t\t\tthat.__alterButtons(buttons[i], function (el) {\n\t\t\t\tel.addClass('hidden');\n\t\t\t});\n\t\t});\n\n\t\treturn this;\n\t},\n\n\tshowButtons: function showButtons(name) {\n\t\tvar buttons = this.__parseButtonNameParam(name),\n\t\t    that = this;\n\n\t\t$.each(buttons, function (i, v) {\n\t\t\tthat.__alterButtons(buttons[i], function (el) {\n\t\t\t\tel.removeClass('hidden');\n\t\t\t});\n\t\t});\n\n\t\treturn this;\n\t},\n\n\teventSupported: function eventSupported(eventName) {\n\t\tvar isSupported = eventName in this.$element;\n\t\tif (!isSupported) {\n\t\t\tthis.$element.setAttribute(eventName, 'return;');\n\t\t\tisSupported = typeof this.$element[eventName] === 'function';\n\t\t}\n\t\treturn isSupported;\n\t},\n\n\tkeyup: function keyup(e) {\n\t\tvar blocked = false;\n\t\tswitch (e.keyCode) {\n\t\t\tcase 40: // down arrow\n\t\t\tcase 38: // up arrow\n\t\t\tcase 16: // shift\n\t\t\tcase 17: // ctrl\n\t\t\tcase 18:\n\t\t\t\t// alt\n\t\t\t\tbreak;\n\n\t\t\tcase 9:\n\t\t\t\t// tab\n\t\t\t\tvar nextTab;\n\t\t\t\tif (nextTab = this.getNextTab(), nextTab != null) {\n\t\t\t\t\t// Get the nextTab if exists\n\t\t\t\t\tvar that = this;\n\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\tthat.setSelection(nextTab.start, nextTab.end);\n\t\t\t\t\t}, 500);\n\n\t\t\t\t\tblocked = true;\n\t\t\t\t} else {\n\t\t\t\t\t// The next tab memory contains nothing...\n\t\t\t\t\t// check the cursor position to determine tab action\n\t\t\t\t\tvar cursor = this.getSelection();\n\n\t\t\t\t\tif (cursor.start == cursor.end && cursor.end == this.getContent().length) {\n\t\t\t\t\t\t// The cursor already reach the end of the content\n\t\t\t\t\t\tblocked = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Put the cursor to the end\n\t\t\t\t\t\tthis.setSelection(this.getContent().length, this.getContent().length);\n\n\t\t\t\t\t\tblocked = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 13:\n\t\t\t\t// enter\n\t\t\t\tblocked = false;\n\t\t\t\tbreak;\n\t\t\tcase 27:\n\t\t\t\t// escape\n\t\t\t\tif (this.$isFullscreen) this.setFullscreen(false);\n\t\t\t\tblocked = false;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tblocked = false;\n\t\t}\n\n\t\tif (blocked) {\n\t\t\te.stopPropagation();\n\t\t\te.preventDefault();\n\t\t}\n\n\t\tthis.$options.onChange(this);\n\t},\n\n\tchange: function change(e) {\n\t\tthis.$options.onChange(this);\n\t\treturn this;\n\t},\n\n\tfocus: function focus(e) {\n\t\tvar options = this.$options,\n\t\t    isHideable = options.hideable,\n\t\t    editor = this.$editor;\n\n\t\teditor.addClass('active');\n\n\t\t// Blur other markdown(s)\n\t\t$(document).find('.md-editor').each(function () {\n\t\t\tif ($(this).attr('id') != editor.attr('id')) {\n\t\t\t\tvar attachedMarkdown;\n\n\t\t\t\tif (attachedMarkdown = $(this).find('textarea').data('markdown'), attachedMarkdown == null) {\n\t\t\t\t\tattachedMarkdown = $(this).find('div[data-provider=\"markdown-preview\"]').data('markdown');\n\t\t\t\t}\n\n\t\t\t\tif (attachedMarkdown) {\n\t\t\t\t\tattachedMarkdown.blur();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// Trigger the onFocus hook\n\t\toptions.onFocus(this);\n\n\t\treturn this;\n\t},\n\n\tblur: function blur(e) {\n\t\tvar options = this.$options,\n\t\t    isHideable = options.hideable,\n\t\t    editor = this.$editor,\n\t\t    editable = this.$editable;\n\n\t\tif (editor.hasClass('active') || this.$element.parent().length == 0) {\n\t\t\teditor.removeClass('active');\n\n\t\t\tif (isHideable) {\n\n\t\t\t\t// Check for editable elements\n\t\t\t\tif (editable.el != null) {\n\t\t\t\t\t// Build the original element\n\t\t\t\t\tvar oldElement = $('<' + editable.type + '/>'),\n\t\t\t\t\t    content = this.getContent(),\n\t\t\t\t\t    currentContent = (typeof markdown === 'undefined' ? 'undefined' : _typeof(markdown)) == 'object' ? markdown.toHTML(content) : content;\n\n\t\t\t\t\t$(editable.attrKeys).each(function (k, v) {\n\t\t\t\t\t\toldElement.attr(editable.attrKeys[k], editable.attrValues[k]);\n\t\t\t\t\t});\n\n\t\t\t\t\t// Get the editor content\n\t\t\t\t\toldElement.html(currentContent);\n\n\t\t\t\t\teditor.replaceWith(oldElement);\n\t\t\t\t} else {\n\t\t\t\t\teditor.hide();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Trigger the onBlur hook\n\t\t\toptions.onBlur(this);\n\t\t}\n\n\t\treturn this;\n\t}\n\n};\n\n/* MARKDOWN PLUGIN DEFINITION\n* ========================== */\n\nvar old = $.fn.markdown;\n\n$.fn.markdown = function (option) {\n\treturn this.each(function () {\n\t\tvar $this = $(this),\n\t\t    data = $this.data('markdown'),\n\t\t    options = (typeof option === 'undefined' ? 'undefined' : _typeof(option)) == 'object' && option;\n\t\tif (!data) $this.data('markdown', data = new Markdown(this, options));\n\t});\n};\n\n$.fn.markdown.messages = {};\n\n$.fn.markdown.defaults = {\n\t/* Editor Properties */\n\tautofocus: false,\n\thideable: false,\n\tsavable: false,\n\twidth: 'inherit',\n\theight: 'inherit',\n\tresize: 'none',\n\ticonlibrary: 'glyph',\n\tlanguage: 'en',\n\tinitialstate: 'editor',\n\n\t/* Buttons Properties */\n\tbuttons: [[{\n\t\tname: 'groupFont',\n\t\tdata: [{\n\t\t\tname: 'cmdBold',\n\t\t\thotkey: 'Ctrl+B',\n\t\t\ttitle: 'Bold',\n\t\t\ticon: { glyph: 'mce-ico mce-i-bold', fa: 'fa fa-bold', 'fa-3': 'icon-bold' },\n\t\t\tcallback: function callback(e) {\n\t\t\t\t// Give/remove ** surround the selection\n\t\t\t\tvar chunk,\n\t\t\t\t    cursor,\n\t\t\t\t    selected = e.getSelection(),\n\t\t\t\t    content = e.getContent();\n\n\t\t\t\tif (selected.length == 0) {\n\t\t\t\t\t// Give extra word\n\t\t\t\t\tchunk = e.__localize('strong text');\n\t\t\t\t} else {\n\t\t\t\t\tchunk = selected.text;\n\t\t\t\t}\n\n\t\t\t\t// transform selection and set the cursor into chunked text\n\t\t\t\tif (content.substr(selected.start - 2, 2) == '**' && content.substr(selected.end, 2) == '**') {\n\t\t\t\t\te.setSelection(selected.start - 2, selected.end + 2);\n\t\t\t\t\te.replaceSelection(chunk);\n\t\t\t\t\tcursor = selected.start - 2;\n\t\t\t\t} else {\n\t\t\t\t\te.replaceSelection('**' + chunk + '**');\n\t\t\t\t\tcursor = selected.start + 2;\n\t\t\t\t}\n\n\t\t\t\t// Set the cursor\n\t\t\t\te.setSelection(cursor, cursor + chunk.length);\n\t\t\t}\n\t\t}, {\n\t\t\tname: 'cmdItalic',\n\t\t\ttitle: 'Italic',\n\t\t\thotkey: 'Ctrl+I',\n\t\t\ticon: { glyph: 'mce-ico mce-i-italic', fa: 'fa fa-italic', 'fa-3': 'icon-italic' },\n\t\t\tcallback: function callback(e) {\n\t\t\t\t// Give/remove * surround the selection\n\t\t\t\tvar chunk,\n\t\t\t\t    cursor,\n\t\t\t\t    selected = e.getSelection(),\n\t\t\t\t    content = e.getContent();\n\n\t\t\t\tif (selected.length == 0) {\n\t\t\t\t\t// Give extra word\n\t\t\t\t\tchunk = e.__localize('emphasized text');\n\t\t\t\t} else {\n\t\t\t\t\tchunk = selected.text;\n\t\t\t\t}\n\n\t\t\t\t// transform selection and set the cursor into chunked text\n\t\t\t\tif (content.substr(selected.start - 1, 1) == '_' && content.substr(selected.end, 1) == '_') {\n\t\t\t\t\te.setSelection(selected.start - 1, selected.end + 1);\n\t\t\t\t\te.replaceSelection(chunk);\n\t\t\t\t\tcursor = selected.start - 1;\n\t\t\t\t} else {\n\t\t\t\t\te.replaceSelection('_' + chunk + '_');\n\t\t\t\t\tcursor = selected.start + 1;\n\t\t\t\t}\n\n\t\t\t\t// Set the cursor\n\t\t\t\te.setSelection(cursor, cursor + chunk.length);\n\t\t\t}\n\t\t}]\n\t}, {\n\t\tname: 'groupLink',\n\t\tdata: [{\n\t\t\tname: 'cmdUrl',\n\t\t\ttitle: 'URL/Link',\n\t\t\thotkey: 'Ctrl+L',\n\t\t\ticon: { glyph: 'mce-ico mce-i-link', fa: 'fa fa-link', 'fa-3': 'icon-link' },\n\t\t\tcallback: function callback(e) {\n\t\t\t\t// Give [] surround the selection and prepend the link\n\t\t\t\tvar chunk,\n\t\t\t\t    cursor,\n\t\t\t\t    selected = e.getSelection(),\n\t\t\t\t    content = e.getContent(),\n\t\t\t\t    link;\n\n\t\t\t\tif (selected.length == 0) {\n\t\t\t\t\t// Give extra word\n\t\t\t\t\tchunk = e.__localize('enter link description here');\n\t\t\t\t} else {\n\t\t\t\t\tchunk = selected.text;\n\t\t\t\t}\n\n\t\t\t\tlink = prompt(e.__localize('Insert Hyperlink'), 'http://');\n\n\t\t\t\tif (link != null && link != '' && link != 'http://' && link.substr(0, 4) == 'http') {\n\t\t\t\t\tvar sanitizedLink = $('<div>' + link + '</div>').text();\n\n\t\t\t\t\t// transform selection and set the cursor into chunked text\n\t\t\t\t\te.replaceSelection('[' + chunk + '](' + sanitizedLink + ')');\n\t\t\t\t\tcursor = selected.start + 1;\n\n\t\t\t\t\t// Set the cursor\n\t\t\t\t\te.setSelection(cursor, cursor + chunk.length);\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tname: 'cmdImage',\n\t\t\ttitle: 'Image',\n\t\t\thotkey: 'Ctrl+G',\n\t\t\ticon: { glyph: 'mce-ico mce-i-image', fa: 'fa fa-picture-o', 'fa-3': 'icon-picture' },\n\t\t\tcallback: function callback(e) {\n\t\t\t\t// Give ![] surround the selection and prepend the image link\n\t\t\t\tvar chunk,\n\t\t\t\t    cursor,\n\t\t\t\t    selected = e.getSelection(),\n\t\t\t\t    content = e.getContent(),\n\t\t\t\t    link;\n\n\t\t\t\tif (selected.length == 0) {\n\t\t\t\t\t// Give extra word\n\t\t\t\t\tchunk = e.__localize('enter image description here');\n\t\t\t\t} else {\n\t\t\t\t\tchunk = selected.text;\n\t\t\t\t}\n\n\t\t\t\tlink = prompt(e.__localize('Insert Image Hyperlink'), 'http://');\n\n\t\t\t\tif (link != null && link != '' && link != 'http://' && link.substr(0, 4) == 'http') {\n\t\t\t\t\tvar sanitizedLink = $('<div>' + link + '</div>').text();\n\n\t\t\t\t\t// transform selection and set the cursor into chunked text\n\t\t\t\t\te.replaceSelection('![' + chunk + '](' + sanitizedLink + ' \"' + e.__localize('enter image title here') + '\")');\n\t\t\t\t\tcursor = selected.start + 2;\n\n\t\t\t\t\t// Set the next tab\n\t\t\t\t\te.setNextTab(e.__localize('enter image title here'));\n\n\t\t\t\t\t// Set the cursor\n\t\t\t\t\te.setSelection(cursor, cursor + chunk.length);\n\t\t\t\t}\n\t\t\t}\n\t\t}]\n\t}, {\n\t\tname: 'groupMisc',\n\t\tdata: [{\n\t\t\tname: 'cmdList',\n\t\t\thotkey: 'Ctrl+U',\n\t\t\ttitle: 'Unordered List',\n\t\t\ticon: { glyph: 'mce-ico mce-i-bullist', fa: 'fa fa-list', 'fa-3': 'icon-list-ul' },\n\t\t\tcallback: function callback(e) {\n\t\t\t\t// Prepend/Give - surround the selection\n\t\t\t\tvar chunk,\n\t\t\t\t    cursor,\n\t\t\t\t    selected = e.getSelection(),\n\t\t\t\t    content = e.getContent();\n\n\t\t\t\t// transform selection and set the cursor into chunked text\n\t\t\t\tif (selected.length == 0) {\n\t\t\t\t\t// Give extra word\n\t\t\t\t\tchunk = e.__localize('list text here');\n\n\t\t\t\t\te.replaceSelection('- ' + chunk);\n\t\t\t\t\t// Set the cursor\n\t\t\t\t\tcursor = selected.start + 2;\n\t\t\t\t} else {\n\t\t\t\t\tif (selected.text.indexOf('\\n') < 0) {\n\t\t\t\t\t\tchunk = selected.text;\n\n\t\t\t\t\t\te.replaceSelection('- ' + chunk);\n\n\t\t\t\t\t\t// Set the cursor\n\t\t\t\t\t\tcursor = selected.start + 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar list = [];\n\n\t\t\t\t\t\tlist = selected.text.split('\\n');\n\t\t\t\t\t\tchunk = list[0];\n\n\t\t\t\t\t\t$.each(list, function (k, v) {\n\t\t\t\t\t\t\tlist[k] = '- ' + v;\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\te.replaceSelection('\\n\\n' + list.join('\\n'));\n\n\t\t\t\t\t\t// Set the cursor\n\t\t\t\t\t\tcursor = selected.start + 4;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Set the cursor\n\t\t\t\te.setSelection(cursor, cursor + chunk.length);\n\t\t\t}\n\t\t}, {\n\t\t\tname: 'cmdListO',\n\t\t\thotkey: 'Ctrl+O',\n\t\t\ttitle: 'Ordered List',\n\t\t\ticon: { glyph: 'mce-ico mce-i-numlist', fa: 'fa fa-list-ol', 'fa-3': 'icon-list-ol' },\n\t\t\tcallback: function callback(e) {\n\n\t\t\t\t// Prepend/Give - surround the selection\n\t\t\t\tvar chunk,\n\t\t\t\t    cursor,\n\t\t\t\t    selected = e.getSelection(),\n\t\t\t\t    content = e.getContent();\n\n\t\t\t\t// transform selection and set the cursor into chunked text\n\t\t\t\tif (selected.length == 0) {\n\t\t\t\t\t// Give extra word\n\t\t\t\t\tchunk = e.__localize('list text here');\n\t\t\t\t\te.replaceSelection('1. ' + chunk);\n\t\t\t\t\t// Set the cursor\n\t\t\t\t\tcursor = selected.start + 3;\n\t\t\t\t} else {\n\t\t\t\t\tif (selected.text.indexOf('\\n') < 0) {\n\t\t\t\t\t\tchunk = selected.text;\n\n\t\t\t\t\t\te.replaceSelection('1. ' + chunk);\n\n\t\t\t\t\t\t// Set the cursor\n\t\t\t\t\t\tcursor = selected.start + 3;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar list = [];\n\n\t\t\t\t\t\tlist = selected.text.split('\\n');\n\t\t\t\t\t\tchunk = list[0];\n\n\t\t\t\t\t\t$.each(list, function (k, v) {\n\t\t\t\t\t\t\tlist[k] = '1. ' + v;\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\te.replaceSelection('\\n\\n' + list.join('\\n'));\n\n\t\t\t\t\t\t// Set the cursor\n\t\t\t\t\t\tcursor = selected.start + 5;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Set the cursor\n\t\t\t\te.setSelection(cursor, cursor + chunk.length);\n\t\t\t}\n\t\t}, {\n\t\t\tname: 'cmdQuote',\n\t\t\thotkey: 'Ctrl+Q',\n\t\t\ttitle: 'Quote',\n\t\t\ticon: { glyph: 'mce-ico mce-i-indent', fa: 'fa fa-quote-left', 'fa-3': 'icon-quote-left' },\n\t\t\tcallback: function callback(e) {\n\t\t\t\t// Prepend/Give - surround the selection\n\t\t\t\tvar chunk,\n\t\t\t\t    cursor,\n\t\t\t\t    selected = e.getSelection(),\n\t\t\t\t    content = e.getContent();\n\n\t\t\t\t// transform selection and set the cursor into chunked text\n\t\t\t\tif (selected.length == 0) {\n\t\t\t\t\t// Give extra word\n\t\t\t\t\tchunk = e.__localize('quote here');\n\t\t\t\t\te.replaceSelection('> ' + chunk);\n\t\t\t\t\t// Set the cursor\n\t\t\t\t\tcursor = selected.start + 2;\n\t\t\t\t} else {\n\t\t\t\t\tif (selected.text.indexOf('\\n') < 0) {\n\t\t\t\t\t\tchunk = selected.text;\n\n\t\t\t\t\t\te.replaceSelection('> ' + chunk);\n\n\t\t\t\t\t\t// Set the cursor\n\t\t\t\t\t\tcursor = selected.start + 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar list = [];\n\n\t\t\t\t\t\tlist = selected.text.split('\\n');\n\t\t\t\t\t\tchunk = list[0];\n\n\t\t\t\t\t\t$.each(list, function (k, v) {\n\t\t\t\t\t\t\tlist[k] = '> ' + v;\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\te.replaceSelection('\\n\\n' + list.join('\\n'));\n\n\t\t\t\t\t\t// Set the cursor\n\t\t\t\t\t\tcursor = selected.start + 4;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Set the cursor\n\t\t\t\te.setSelection(cursor, cursor + chunk.length);\n\t\t\t}\n\t\t}, {\n\t\t\tname: 'cmdCode',\n\t\t\thotkey: 'Ctrl+K',\n\t\t\ttitle: 'Code',\n\t\t\ticon: { glyph: 'mce-ico mce-i-code', fa: 'fa fa-code', 'fa-3': 'icon-code' },\n\t\t\tcallback: function callback(e) {\n\n\t\t\t\t// Give/remove ** surround the selection\n\t\t\t\tvar chunk,\n\t\t\t\t    cursor,\n\t\t\t\t    selected = e.getSelection(),\n\t\t\t\t    content = e.getContent();\n\n\t\t\t\tif (selected.length == 0) {\n\t\t\t\t\t// Give extra word\n\t\t\t\t\tchunk = e.__localize('code text here');\n\t\t\t\t} else {\n\t\t\t\t\tchunk = selected.text;\n\t\t\t\t}\n\n\t\t\t\t// transform selection and set the cursor into chunked text\n\t\t\t\tif (content.substr(selected.start - 1, 1) == '`' && content.substr(selected.end, 1) == '`') {\n\t\t\t\t\te.setSelection(selected.start - 1, selected.end + 1);\n\t\t\t\t\te.replaceSelection(chunk);\n\t\t\t\t\tcursor = selected.start - 1;\n\t\t\t\t} else {\n\t\t\t\t\te.replaceSelection('`' + chunk + '`');\n\t\t\t\t\tcursor = selected.start + 1;\n\t\t\t\t}\n\n\t\t\t\t// Set the cursor\n\t\t\t\te.setSelection(cursor, cursor + chunk.length);\n\t\t\t}\n\t\t}]\n\t}, {\n\t\tname: 'groupUtil',\n\t\tdata: [{\n\t\t\tname: 'cmdPreview',\n\t\t\ttoggle: true,\n\t\t\thotkey: 'Ctrl+P',\n\t\t\ttitle: 'Preview',\n\t\t\tbtnText: 'Preview',\n\t\t\tbtnClass: 'btn btn-sm',\n\t\t\ticon: { glyph: 'glyphicon glyphicon-search', fa: 'fa fa-search', 'fa-3': 'icon-search' },\n\t\t\tcallback: function callback(e) {\n\t\t\t\t// Check the preview mode and toggle based on this flag\n\t\t\t\tvar isPreview = e.$isPreview,\n\t\t\t\t    content;\n\n\t\t\t\tif (isPreview == false) {\n\t\t\t\t\t// Give flag that tell the editor enter preview mode\n\t\t\t\t\te.showPreview();\n\t\t\t\t} else {\n\t\t\t\t\te.hidePreview();\n\t\t\t\t}\n\t\t\t}\n\t\t}]\n\t}]],\n\tadditionalButtons: [], // Place to hook more buttons by code\n\treorderButtonGroups: [],\n\thiddenButtons: [], // Default hidden buttons\n\tdisabledButtons: [], // Default disabled buttons\n\tfooter: '',\n\tfullscreen: {\n\t\tenable: true,\n\t\ticons: {\n\t\t\tfullscreenOn: {\n\t\t\t\tfa: 'fa fa-expand',\n\t\t\t\tglyph: 'glyphicon glyphicon-fullscreen',\n\t\t\t\t'fa-3': 'icon-resize-full'\n\t\t\t},\n\t\t\tfullscreenOff: {\n\t\t\t\tfa: 'fa fa-compress',\n\t\t\t\tglyph: 'glyphicon glyphicon-fullscreen',\n\t\t\t\t'fa-3': 'icon-resize-small'\n\t\t\t}\n\t\t}\n\t},\n\n\t/* Events hook */\n\tonShow: function onShow(e) {},\n\tonPreview: function onPreview(e) {},\n\tonSave: function onSave(e) {},\n\tonBlur: function onBlur(e) {},\n\tonFocus: function onFocus(e) {},\n\tonChange: function onChange(e) {},\n\tonFullscreen: function onFullscreen(e) {}\n};\n\n$.fn.markdown.Constructor = Markdown;\n\n/* MARKDOWN NO CONFLICT\n* ==================== */\n\n$.fn.markdown.noConflict = function () {\n\t$.fn.markdown = old;\n\treturn this;\n};\n\n/* MARKDOWN GLOBAL FUNCTION & DATA-API\n* ==================================== */\nvar initMarkdown = function initMarkdown(el) {\n\tvar $this = el;\n\n\tif ($this.data('markdown')) {\n\t\t$this.data('markdown').showEditor();\n\t\treturn;\n\t}\n\n\t$this.markdown();\n};\n\nvar analyzeMarkdown = function analyzeMarkdown(e) {\n\tvar blurred = false,\n\t    el,\n\t    $docEditor = $(e.currentTarget);\n\n\t// Check whether it was editor childs or not\n\tif ((e.type == 'focusin' || e.type == 'click') && $docEditor.length == 1 && _typeof($docEditor[0]) == 'object') {\n\t\tel = $docEditor[0].activeElement;\n\t\tif (!$(el).data('markdown')) {\n\t\t\tif (typeof $(el).parent().parent().parent().attr('class') == \"undefined\" || $(el).parent().parent().parent().attr('class').indexOf('md-editor') < 0) {\n\t\t\t\tif (typeof $(el).parent().parent().attr('class') == \"undefined\" || $(el).parent().parent().attr('class').indexOf('md-editor') < 0) {\n\n\t\t\t\t\tblurred = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tblurred = false;\n\t\t\t}\n\t\t}\n\n\t\tif (blurred) {\n\t\t\t// Blur event\n\t\t\t$(document).find('.md-editor').each(function () {\n\t\t\t\tvar parentMd = $(el).parent();\n\n\t\t\t\tif ($(this).attr('id') != parentMd.attr('id')) {\n\t\t\t\t\tvar attachedMarkdown;\n\n\t\t\t\t\tif (attachedMarkdown = $(this).find('textarea').data('markdown'), attachedMarkdown == null) {\n\t\t\t\t\t\tattachedMarkdown = $(this).find('div[data-provider=\"markdown-preview\"]').data('markdown');\n\t\t\t\t\t}\n\n\t\t\t\t\tif (attachedMarkdown) {\n\t\t\t\t\t\tattachedMarkdown.blur();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\te.stopPropagation();\n\t}\n};\n\n$(document).on('click.markdown.data-api', '[data-provide=\"markdown-editable\"]', function (e) {\n\tinitMarkdown($(this));\n\te.preventDefault();\n}).on('click', function (e) {\n\tanalyzeMarkdown(e);\n}).on('focusin', function (e) {\n\tanalyzeMarkdown(e);\n}).ready(function () {\n\t$('textarea[data-provide=\"markdown\"]').each(function () {\n\t\tinitMarkdown($(this));\n\t});\n});\n\n//////////////////\n// WEBPACK FOOTER\n// ./fields/types/markdown/lib/bootstrap-markdown.js\n// module id = 737\n// module chunks = 8\n//# sourceURL=webpack:///./fields/types/markdown/lib/bootstrap-markdown.js?");

/***/ },

/***/ 1207:
/*!********************************!*\
  !*** ./~/marked/lib/marked.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * marked - a markdown parser\n * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/chjj/marked\n */\n\n;(function() {\n\n/**\n * Block-Level Grammar\n */\n\nvar block = {\n  newline: /^\\n+/,\n  code: /^( {4}[^\\n]+\\n*)+/,\n  fences: noop,\n  hr: /^( *[-*_]){3,} *(?:\\n+|$)/,\n  heading: /^ *(#{1,6}) *([^\\n]+?) *#* *(?:\\n+|$)/,\n  nptable: noop,\n  lheading: /^([^\\n]+)\\n *(=|-){2,} *(?:\\n+|$)/,\n  blockquote: /^( *>[^\\n]+(\\n(?!def)[^\\n]+)*\\n*)+/,\n  list: /^( *)(bull) [\\s\\S]+?(?:hr|def|\\n{2,}(?! )(?!\\1bull )\\n*|\\s*$)/,\n  html: /^ *(?:comment *(?:\\n|\\s*$)|closed *(?:\\n{2,}|\\s*$)|closing *(?:\\n{2,}|\\s*$))/,\n  def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +[\"(]([^\\n]+)[\")])? *(?:\\n+|$)/,\n  table: noop,\n  paragraph: /^((?:[^\\n]+\\n?(?!hr|heading|lheading|blockquote|tag|def))+)\\n*/,\n  text: /^[^\\n]+/\n};\n\nblock.bullet = /(?:[*+-]|\\d+\\.)/;\nblock.item = /^( *)(bull) [^\\n]*(?:\\n(?!\\1bull )[^\\n]*)*/;\nblock.item = replace(block.item, 'gm')\n  (/bull/g, block.bullet)\n  ();\n\nblock.list = replace(block.list)\n  (/bull/g, block.bullet)\n  ('hr', '\\\\n+(?=\\\\1?(?:[-*_] *){3,}(?:\\\\n+|$))')\n  ('def', '\\\\n+(?=' + block.def.source + ')')\n  ();\n\nblock.blockquote = replace(block.blockquote)\n  ('def', block.def)\n  ();\n\nblock._tag = '(?!(?:'\n  + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'\n  + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'\n  + '|span|br|wbr|ins|del|img)\\\\b)\\\\w+(?!:/|[^\\\\w\\\\s@]*@)\\\\b';\n\nblock.html = replace(block.html)\n  ('comment', /<!--[\\s\\S]*?-->/)\n  ('closed', /<(tag)[\\s\\S]+?<\\/\\1>/)\n  ('closing', /<tag(?:\"[^\"]*\"|'[^']*'|[^'\">])*?>/)\n  (/tag/g, block._tag)\n  ();\n\nblock.paragraph = replace(block.paragraph)\n  ('hr', block.hr)\n  ('heading', block.heading)\n  ('lheading', block.lheading)\n  ('blockquote', block.blockquote)\n  ('tag', '<' + block._tag)\n  ('def', block.def)\n  ();\n\n/**\n * Normal Block Grammar\n */\n\nblock.normal = merge({}, block);\n\n/**\n * GFM Block Grammar\n */\n\nblock.gfm = merge({}, block.normal, {\n  fences: /^ *(`{3,}|~{3,})[ \\.]*(\\S+)? *\\n([\\s\\S]*?)\\s*\\1 *(?:\\n+|$)/,\n  paragraph: /^/,\n  heading: /^ *(#{1,6}) +([^\\n]+?) *#* *(?:\\n+|$)/\n});\n\nblock.gfm.paragraph = replace(block.paragraph)\n  ('(?!', '(?!'\n    + block.gfm.fences.source.replace('\\\\1', '\\\\2') + '|'\n    + block.list.source.replace('\\\\1', '\\\\3') + '|')\n  ();\n\n/**\n * GFM + Tables Block Grammar\n */\n\nblock.tables = merge({}, block.gfm, {\n  nptable: /^ *(\\S.*\\|.*)\\n *([-:]+ *\\|[-| :]*)\\n((?:.*\\|.*(?:\\n|$))*)\\n*/,\n  table: /^ *\\|(.+)\\n *\\|( *[-:]+[-| :]*)\\n((?: *\\|.*(?:\\n|$))*)\\n*/\n});\n\n/**\n * Block Lexer\n */\n\nfunction Lexer(options) {\n  this.tokens = [];\n  this.tokens.links = {};\n  this.options = options || marked.defaults;\n  this.rules = block.normal;\n\n  if (this.options.gfm) {\n    if (this.options.tables) {\n      this.rules = block.tables;\n    } else {\n      this.rules = block.gfm;\n    }\n  }\n}\n\n/**\n * Expose Block Rules\n */\n\nLexer.rules = block;\n\n/**\n * Static Lex Method\n */\n\nLexer.lex = function(src, options) {\n  var lexer = new Lexer(options);\n  return lexer.lex(src);\n};\n\n/**\n * Preprocessing\n */\n\nLexer.prototype.lex = function(src) {\n  src = src\n    .replace(/\\r\\n|\\r/g, '\\n')\n    .replace(/\\t/g, '    ')\n    .replace(/\\u00a0/g, ' ')\n    .replace(/\\u2424/g, '\\n');\n\n  return this.token(src, true);\n};\n\n/**\n * Lexing\n */\n\nLexer.prototype.token = function(src, top, bq) {\n  var src = src.replace(/^ +$/gm, '')\n    , next\n    , loose\n    , cap\n    , bull\n    , b\n    , item\n    , space\n    , i\n    , l;\n\n  while (src) {\n    // newline\n    if (cap = this.rules.newline.exec(src)) {\n      src = src.substring(cap[0].length);\n      if (cap[0].length > 1) {\n        this.tokens.push({\n          type: 'space'\n        });\n      }\n    }\n\n    // code\n    if (cap = this.rules.code.exec(src)) {\n      src = src.substring(cap[0].length);\n      cap = cap[0].replace(/^ {4}/gm, '');\n      this.tokens.push({\n        type: 'code',\n        text: !this.options.pedantic\n          ? cap.replace(/\\n+$/, '')\n          : cap\n      });\n      continue;\n    }\n\n    // fences (gfm)\n    if (cap = this.rules.fences.exec(src)) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'code',\n        lang: cap[2],\n        text: cap[3] || ''\n      });\n      continue;\n    }\n\n    // heading\n    if (cap = this.rules.heading.exec(src)) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'heading',\n        depth: cap[1].length,\n        text: cap[2]\n      });\n      continue;\n    }\n\n    // table no leading pipe (gfm)\n    if (top && (cap = this.rules.nptable.exec(src))) {\n      src = src.substring(cap[0].length);\n\n      item = {\n        type: 'table',\n        header: cap[1].replace(/^ *| *\\| *$/g, '').split(/ *\\| */),\n        align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n        cells: cap[3].replace(/\\n$/, '').split('\\n')\n      };\n\n      for (i = 0; i < item.align.length; i++) {\n        if (/^ *-+: *$/.test(item.align[i])) {\n          item.align[i] = 'right';\n        } else if (/^ *:-+: *$/.test(item.align[i])) {\n          item.align[i] = 'center';\n        } else if (/^ *:-+ *$/.test(item.align[i])) {\n          item.align[i] = 'left';\n        } else {\n          item.align[i] = null;\n        }\n      }\n\n      for (i = 0; i < item.cells.length; i++) {\n        item.cells[i] = item.cells[i].split(/ *\\| */);\n      }\n\n      this.tokens.push(item);\n\n      continue;\n    }\n\n    // lheading\n    if (cap = this.rules.lheading.exec(src)) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'heading',\n        depth: cap[2] === '=' ? 1 : 2,\n        text: cap[1]\n      });\n      continue;\n    }\n\n    // hr\n    if (cap = this.rules.hr.exec(src)) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'hr'\n      });\n      continue;\n    }\n\n    // blockquote\n    if (cap = this.rules.blockquote.exec(src)) {\n      src = src.substring(cap[0].length);\n\n      this.tokens.push({\n        type: 'blockquote_start'\n      });\n\n      cap = cap[0].replace(/^ *> ?/gm, '');\n\n      // Pass `top` to keep the current\n      // \"toplevel\" state. This is exactly\n      // how markdown.pl works.\n      this.token(cap, top, true);\n\n      this.tokens.push({\n        type: 'blockquote_end'\n      });\n\n      continue;\n    }\n\n    // list\n    if (cap = this.rules.list.exec(src)) {\n      src = src.substring(cap[0].length);\n      bull = cap[2];\n\n      this.tokens.push({\n        type: 'list_start',\n        ordered: bull.length > 1\n      });\n\n      // Get each top-level item.\n      cap = cap[0].match(this.rules.item);\n\n      next = false;\n      l = cap.length;\n      i = 0;\n\n      for (; i < l; i++) {\n        item = cap[i];\n\n        // Remove the list item's bullet\n        // so it is seen as the next token.\n        space = item.length;\n        item = item.replace(/^ *([*+-]|\\d+\\.) +/, '');\n\n        // Outdent whatever the\n        // list item contains. Hacky.\n        if (~item.indexOf('\\n ')) {\n          space -= item.length;\n          item = !this.options.pedantic\n            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')\n            : item.replace(/^ {1,4}/gm, '');\n        }\n\n        // Determine whether the next list item belongs here.\n        // Backpedal if it does not belong in this list.\n        if (this.options.smartLists && i !== l - 1) {\n          b = block.bullet.exec(cap[i + 1])[0];\n          if (bull !== b && !(bull.length > 1 && b.length > 1)) {\n            src = cap.slice(i + 1).join('\\n') + src;\n            i = l - 1;\n          }\n        }\n\n        // Determine whether item is loose or not.\n        // Use: /(^|\\n)(?! )[^\\n]+\\n\\n(?!\\s*$)/\n        // for discount behavior.\n        loose = next || /\\n\\n(?!\\s*$)/.test(item);\n        if (i !== l - 1) {\n          next = item.charAt(item.length - 1) === '\\n';\n          if (!loose) loose = next;\n        }\n\n        this.tokens.push({\n          type: loose\n            ? 'loose_item_start'\n            : 'list_item_start'\n        });\n\n        // Recurse.\n        this.token(item, false, bq);\n\n        this.tokens.push({\n          type: 'list_item_end'\n        });\n      }\n\n      this.tokens.push({\n        type: 'list_end'\n      });\n\n      continue;\n    }\n\n    // html\n    if (cap = this.rules.html.exec(src)) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: this.options.sanitize\n          ? 'paragraph'\n          : 'html',\n        pre: !this.options.sanitizer\n          && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),\n        text: cap[0]\n      });\n      continue;\n    }\n\n    // def\n    if ((!bq && top) && (cap = this.rules.def.exec(src))) {\n      src = src.substring(cap[0].length);\n      this.tokens.links[cap[1].toLowerCase()] = {\n        href: cap[2],\n        title: cap[3]\n      };\n      continue;\n    }\n\n    // table (gfm)\n    if (top && (cap = this.rules.table.exec(src))) {\n      src = src.substring(cap[0].length);\n\n      item = {\n        type: 'table',\n        header: cap[1].replace(/^ *| *\\| *$/g, '').split(/ *\\| */),\n        align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n        cells: cap[3].replace(/(?: *\\| *)?\\n$/, '').split('\\n')\n      };\n\n      for (i = 0; i < item.align.length; i++) {\n        if (/^ *-+: *$/.test(item.align[i])) {\n          item.align[i] = 'right';\n        } else if (/^ *:-+: *$/.test(item.align[i])) {\n          item.align[i] = 'center';\n        } else if (/^ *:-+ *$/.test(item.align[i])) {\n          item.align[i] = 'left';\n        } else {\n          item.align[i] = null;\n        }\n      }\n\n      for (i = 0; i < item.cells.length; i++) {\n        item.cells[i] = item.cells[i]\n          .replace(/^ *\\| *| *\\| *$/g, '')\n          .split(/ *\\| */);\n      }\n\n      this.tokens.push(item);\n\n      continue;\n    }\n\n    // top-level paragraph\n    if (top && (cap = this.rules.paragraph.exec(src))) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'paragraph',\n        text: cap[1].charAt(cap[1].length - 1) === '\\n'\n          ? cap[1].slice(0, -1)\n          : cap[1]\n      });\n      continue;\n    }\n\n    // text\n    if (cap = this.rules.text.exec(src)) {\n      // Top-level should never reach here.\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'text',\n        text: cap[0]\n      });\n      continue;\n    }\n\n    if (src) {\n      throw new\n        Error('Infinite loop on byte: ' + src.charCodeAt(0));\n    }\n  }\n\n  return this.tokens;\n};\n\n/**\n * Inline-Level Grammar\n */\n\nvar inline = {\n  escape: /^\\\\([\\\\`*{}\\[\\]()#+\\-.!_>])/,\n  autolink: /^<([^ >]+(@|:\\/)[^ >]+)>/,\n  url: noop,\n  tag: /^<!--[\\s\\S]*?-->|^<\\/?\\w+(?:\"[^\"]*\"|'[^']*'|[^'\">])*?>/,\n  link: /^!?\\[(inside)\\]\\(href\\)/,\n  reflink: /^!?\\[(inside)\\]\\s*\\[([^\\]]*)\\]/,\n  nolink: /^!?\\[((?:\\[[^\\]]*\\]|[^\\[\\]])*)\\]/,\n  strong: /^__([\\s\\S]+?)__(?!_)|^\\*\\*([\\s\\S]+?)\\*\\*(?!\\*)/,\n  em: /^\\b_((?:[^_]|__)+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n  code: /^(`+)\\s*([\\s\\S]*?[^`])\\s*\\1(?!`)/,\n  br: /^ {2,}\\n(?!\\s*$)/,\n  del: noop,\n  text: /^[\\s\\S]+?(?=[\\\\<!\\[_*`]| {2,}\\n|$)/\n};\n\ninline._inside = /(?:\\[[^\\]]*\\]|[^\\[\\]]|\\](?=[^\\[]*\\]))*/;\ninline._href = /\\s*<?([\\s\\S]*?)>?(?:\\s+['\"]([\\s\\S]*?)['\"])?\\s*/;\n\ninline.link = replace(inline.link)\n  ('inside', inline._inside)\n  ('href', inline._href)\n  ();\n\ninline.reflink = replace(inline.reflink)\n  ('inside', inline._inside)\n  ();\n\n/**\n * Normal Inline Grammar\n */\n\ninline.normal = merge({}, inline);\n\n/**\n * Pedantic Inline Grammar\n */\n\ninline.pedantic = merge({}, inline.normal, {\n  strong: /^__(?=\\S)([\\s\\S]*?\\S)__(?!_)|^\\*\\*(?=\\S)([\\s\\S]*?\\S)\\*\\*(?!\\*)/,\n  em: /^_(?=\\S)([\\s\\S]*?\\S)_(?!_)|^\\*(?=\\S)([\\s\\S]*?\\S)\\*(?!\\*)/\n});\n\n/**\n * GFM Inline Grammar\n */\n\ninline.gfm = merge({}, inline.normal, {\n  escape: replace(inline.escape)('])', '~|])')(),\n  url: /^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])/,\n  del: /^~~(?=\\S)([\\s\\S]*?\\S)~~/,\n  text: replace(inline.text)\n    (']|', '~]|')\n    ('|', '|https?://|')\n    ()\n});\n\n/**\n * GFM + Line Breaks Inline Grammar\n */\n\ninline.breaks = merge({}, inline.gfm, {\n  br: replace(inline.br)('{2,}', '*')(),\n  text: replace(inline.gfm.text)('{2,}', '*')()\n});\n\n/**\n * Inline Lexer & Compiler\n */\n\nfunction InlineLexer(links, options) {\n  this.options = options || marked.defaults;\n  this.links = links;\n  this.rules = inline.normal;\n  this.renderer = this.options.renderer || new Renderer;\n  this.renderer.options = this.options;\n\n  if (!this.links) {\n    throw new\n      Error('Tokens array requires a `links` property.');\n  }\n\n  if (this.options.gfm) {\n    if (this.options.breaks) {\n      this.rules = inline.breaks;\n    } else {\n      this.rules = inline.gfm;\n    }\n  } else if (this.options.pedantic) {\n    this.rules = inline.pedantic;\n  }\n}\n\n/**\n * Expose Inline Rules\n */\n\nInlineLexer.rules = inline;\n\n/**\n * Static Lexing/Compiling Method\n */\n\nInlineLexer.output = function(src, links, options) {\n  var inline = new InlineLexer(links, options);\n  return inline.output(src);\n};\n\n/**\n * Lexing/Compiling\n */\n\nInlineLexer.prototype.output = function(src) {\n  var out = ''\n    , link\n    , text\n    , href\n    , cap;\n\n  while (src) {\n    // escape\n    if (cap = this.rules.escape.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += cap[1];\n      continue;\n    }\n\n    // autolink\n    if (cap = this.rules.autolink.exec(src)) {\n      src = src.substring(cap[0].length);\n      if (cap[2] === '@') {\n        text = cap[1].charAt(6) === ':'\n          ? this.mangle(cap[1].substring(7))\n          : this.mangle(cap[1]);\n        href = this.mangle('mailto:') + text;\n      } else {\n        text = escape(cap[1]);\n        href = text;\n      }\n      out += this.renderer.link(href, null, text);\n      continue;\n    }\n\n    // url (gfm)\n    if (!this.inLink && (cap = this.rules.url.exec(src))) {\n      src = src.substring(cap[0].length);\n      text = escape(cap[1]);\n      href = text;\n      out += this.renderer.link(href, null, text);\n      continue;\n    }\n\n    // tag\n    if (cap = this.rules.tag.exec(src)) {\n      if (!this.inLink && /^<a /i.test(cap[0])) {\n        this.inLink = true;\n      } else if (this.inLink && /^<\\/a>/i.test(cap[0])) {\n        this.inLink = false;\n      }\n      src = src.substring(cap[0].length);\n      out += this.options.sanitize\n        ? this.options.sanitizer\n          ? this.options.sanitizer(cap[0])\n          : escape(cap[0])\n        : cap[0]\n      continue;\n    }\n\n    // link\n    if (cap = this.rules.link.exec(src)) {\n      src = src.substring(cap[0].length);\n      this.inLink = true;\n      out += this.outputLink(cap, {\n        href: cap[2],\n        title: cap[3]\n      });\n      this.inLink = false;\n      continue;\n    }\n\n    // reflink, nolink\n    if ((cap = this.rules.reflink.exec(src))\n        || (cap = this.rules.nolink.exec(src))) {\n      src = src.substring(cap[0].length);\n      link = (cap[2] || cap[1]).replace(/\\s+/g, ' ');\n      link = this.links[link.toLowerCase()];\n      if (!link || !link.href) {\n        out += cap[0].charAt(0);\n        src = cap[0].substring(1) + src;\n        continue;\n      }\n      this.inLink = true;\n      out += this.outputLink(cap, link);\n      this.inLink = false;\n      continue;\n    }\n\n    // strong\n    if (cap = this.rules.strong.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += this.renderer.strong(this.output(cap[2] || cap[1]));\n      continue;\n    }\n\n    // em\n    if (cap = this.rules.em.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += this.renderer.em(this.output(cap[2] || cap[1]));\n      continue;\n    }\n\n    // code\n    if (cap = this.rules.code.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += this.renderer.codespan(escape(cap[2], true));\n      continue;\n    }\n\n    // br\n    if (cap = this.rules.br.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += this.renderer.br();\n      continue;\n    }\n\n    // del (gfm)\n    if (cap = this.rules.del.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += this.renderer.del(this.output(cap[1]));\n      continue;\n    }\n\n    // text\n    if (cap = this.rules.text.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += this.renderer.text(escape(this.smartypants(cap[0])));\n      continue;\n    }\n\n    if (src) {\n      throw new\n        Error('Infinite loop on byte: ' + src.charCodeAt(0));\n    }\n  }\n\n  return out;\n};\n\n/**\n * Compile Link\n */\n\nInlineLexer.prototype.outputLink = function(cap, link) {\n  var href = escape(link.href)\n    , title = link.title ? escape(link.title) : null;\n\n  return cap[0].charAt(0) !== '!'\n    ? this.renderer.link(href, title, this.output(cap[1]))\n    : this.renderer.image(href, title, escape(cap[1]));\n};\n\n/**\n * Smartypants Transformations\n */\n\nInlineLexer.prototype.smartypants = function(text) {\n  if (!this.options.smartypants) return text;\n  return text\n    // em-dashes\n    .replace(/---/g, '\\u2014')\n    // en-dashes\n    .replace(/--/g, '\\u2013')\n    // opening singles\n    .replace(/(^|[-\\u2014/(\\[{\"\\s])'/g, '$1\\u2018')\n    // closing singles & apostrophes\n    .replace(/'/g, '\\u2019')\n    // opening doubles\n    .replace(/(^|[-\\u2014/(\\[{\\u2018\\s])\"/g, '$1\\u201c')\n    // closing doubles\n    .replace(/\"/g, '\\u201d')\n    // ellipses\n    .replace(/\\.{3}/g, '\\u2026');\n};\n\n/**\n * Mangle Links\n */\n\nInlineLexer.prototype.mangle = function(text) {\n  if (!this.options.mangle) return text;\n  var out = ''\n    , l = text.length\n    , i = 0\n    , ch;\n\n  for (; i < l; i++) {\n    ch = text.charCodeAt(i);\n    if (Math.random() > 0.5) {\n      ch = 'x' + ch.toString(16);\n    }\n    out += '&#' + ch + ';';\n  }\n\n  return out;\n};\n\n/**\n * Renderer\n */\n\nfunction Renderer(options) {\n  this.options = options || {};\n}\n\nRenderer.prototype.code = function(code, lang, escaped) {\n  if (this.options.highlight) {\n    var out = this.options.highlight(code, lang);\n    if (out != null && out !== code) {\n      escaped = true;\n      code = out;\n    }\n  }\n\n  if (!lang) {\n    return '<pre><code>'\n      + (escaped ? code : escape(code, true))\n      + '\\n</code></pre>';\n  }\n\n  return '<pre><code class=\"'\n    + this.options.langPrefix\n    + escape(lang, true)\n    + '\">'\n    + (escaped ? code : escape(code, true))\n    + '\\n</code></pre>\\n';\n};\n\nRenderer.prototype.blockquote = function(quote) {\n  return '<blockquote>\\n' + quote + '</blockquote>\\n';\n};\n\nRenderer.prototype.html = function(html) {\n  return html;\n};\n\nRenderer.prototype.heading = function(text, level, raw) {\n  return '<h'\n    + level\n    + ' id=\"'\n    + this.options.headerPrefix\n    + raw.toLowerCase().replace(/[^\\w]+/g, '-')\n    + '\">'\n    + text\n    + '</h'\n    + level\n    + '>\\n';\n};\n\nRenderer.prototype.hr = function() {\n  return this.options.xhtml ? '<hr/>\\n' : '<hr>\\n';\n};\n\nRenderer.prototype.list = function(body, ordered) {\n  var type = ordered ? 'ol' : 'ul';\n  return '<' + type + '>\\n' + body + '</' + type + '>\\n';\n};\n\nRenderer.prototype.listitem = function(text) {\n  return '<li>' + text + '</li>\\n';\n};\n\nRenderer.prototype.paragraph = function(text) {\n  return '<p>' + text + '</p>\\n';\n};\n\nRenderer.prototype.table = function(header, body) {\n  return '<table>\\n'\n    + '<thead>\\n'\n    + header\n    + '</thead>\\n'\n    + '<tbody>\\n'\n    + body\n    + '</tbody>\\n'\n    + '</table>\\n';\n};\n\nRenderer.prototype.tablerow = function(content) {\n  return '<tr>\\n' + content + '</tr>\\n';\n};\n\nRenderer.prototype.tablecell = function(content, flags) {\n  var type = flags.header ? 'th' : 'td';\n  var tag = flags.align\n    ? '<' + type + ' style=\"text-align:' + flags.align + '\">'\n    : '<' + type + '>';\n  return tag + content + '</' + type + '>\\n';\n};\n\n// span level renderer\nRenderer.prototype.strong = function(text) {\n  return '<strong>' + text + '</strong>';\n};\n\nRenderer.prototype.em = function(text) {\n  return '<em>' + text + '</em>';\n};\n\nRenderer.prototype.codespan = function(text) {\n  return '<code>' + text + '</code>';\n};\n\nRenderer.prototype.br = function() {\n  return this.options.xhtml ? '<br/>' : '<br>';\n};\n\nRenderer.prototype.del = function(text) {\n  return '<del>' + text + '</del>';\n};\n\nRenderer.prototype.link = function(href, title, text) {\n  if (this.options.sanitize) {\n    try {\n      var prot = decodeURIComponent(unescape(href))\n        .replace(/[^\\w:]/g, '')\n        .toLowerCase();\n    } catch (e) {\n      return '';\n    }\n    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0) {\n      return '';\n    }\n  }\n  var out = '<a href=\"' + href + '\"';\n  if (title) {\n    out += ' title=\"' + title + '\"';\n  }\n  out += '>' + text + '</a>';\n  return out;\n};\n\nRenderer.prototype.image = function(href, title, text) {\n  var out = '<img src=\"' + href + '\" alt=\"' + text + '\"';\n  if (title) {\n    out += ' title=\"' + title + '\"';\n  }\n  out += this.options.xhtml ? '/>' : '>';\n  return out;\n};\n\nRenderer.prototype.text = function(text) {\n  return text;\n};\n\n/**\n * Parsing & Compiling\n */\n\nfunction Parser(options) {\n  this.tokens = [];\n  this.token = null;\n  this.options = options || marked.defaults;\n  this.options.renderer = this.options.renderer || new Renderer;\n  this.renderer = this.options.renderer;\n  this.renderer.options = this.options;\n}\n\n/**\n * Static Parse Method\n */\n\nParser.parse = function(src, options, renderer) {\n  var parser = new Parser(options, renderer);\n  return parser.parse(src);\n};\n\n/**\n * Parse Loop\n */\n\nParser.prototype.parse = function(src) {\n  this.inline = new InlineLexer(src.links, this.options, this.renderer);\n  this.tokens = src.reverse();\n\n  var out = '';\n  while (this.next()) {\n    out += this.tok();\n  }\n\n  return out;\n};\n\n/**\n * Next Token\n */\n\nParser.prototype.next = function() {\n  return this.token = this.tokens.pop();\n};\n\n/**\n * Preview Next Token\n */\n\nParser.prototype.peek = function() {\n  return this.tokens[this.tokens.length - 1] || 0;\n};\n\n/**\n * Parse Text Tokens\n */\n\nParser.prototype.parseText = function() {\n  var body = this.token.text;\n\n  while (this.peek().type === 'text') {\n    body += '\\n' + this.next().text;\n  }\n\n  return this.inline.output(body);\n};\n\n/**\n * Parse Current Token\n */\n\nParser.prototype.tok = function() {\n  switch (this.token.type) {\n    case 'space': {\n      return '';\n    }\n    case 'hr': {\n      return this.renderer.hr();\n    }\n    case 'heading': {\n      return this.renderer.heading(\n        this.inline.output(this.token.text),\n        this.token.depth,\n        this.token.text);\n    }\n    case 'code': {\n      return this.renderer.code(this.token.text,\n        this.token.lang,\n        this.token.escaped);\n    }\n    case 'table': {\n      var header = ''\n        , body = ''\n        , i\n        , row\n        , cell\n        , flags\n        , j;\n\n      // header\n      cell = '';\n      for (i = 0; i < this.token.header.length; i++) {\n        flags = { header: true, align: this.token.align[i] };\n        cell += this.renderer.tablecell(\n          this.inline.output(this.token.header[i]),\n          { header: true, align: this.token.align[i] }\n        );\n      }\n      header += this.renderer.tablerow(cell);\n\n      for (i = 0; i < this.token.cells.length; i++) {\n        row = this.token.cells[i];\n\n        cell = '';\n        for (j = 0; j < row.length; j++) {\n          cell += this.renderer.tablecell(\n            this.inline.output(row[j]),\n            { header: false, align: this.token.align[j] }\n          );\n        }\n\n        body += this.renderer.tablerow(cell);\n      }\n      return this.renderer.table(header, body);\n    }\n    case 'blockquote_start': {\n      var body = '';\n\n      while (this.next().type !== 'blockquote_end') {\n        body += this.tok();\n      }\n\n      return this.renderer.blockquote(body);\n    }\n    case 'list_start': {\n      var body = ''\n        , ordered = this.token.ordered;\n\n      while (this.next().type !== 'list_end') {\n        body += this.tok();\n      }\n\n      return this.renderer.list(body, ordered);\n    }\n    case 'list_item_start': {\n      var body = '';\n\n      while (this.next().type !== 'list_item_end') {\n        body += this.token.type === 'text'\n          ? this.parseText()\n          : this.tok();\n      }\n\n      return this.renderer.listitem(body);\n    }\n    case 'loose_item_start': {\n      var body = '';\n\n      while (this.next().type !== 'list_item_end') {\n        body += this.tok();\n      }\n\n      return this.renderer.listitem(body);\n    }\n    case 'html': {\n      var html = !this.token.pre && !this.options.pedantic\n        ? this.inline.output(this.token.text)\n        : this.token.text;\n      return this.renderer.html(html);\n    }\n    case 'paragraph': {\n      return this.renderer.paragraph(this.inline.output(this.token.text));\n    }\n    case 'text': {\n      return this.renderer.paragraph(this.parseText());\n    }\n  }\n};\n\n/**\n * Helpers\n */\n\nfunction escape(html, encode) {\n  return html\n    .replace(!encode ? /&(?!#?\\w+;)/g : /&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#39;');\n}\n\nfunction unescape(html) {\n\t// explicitly match decimal, hex, and named HTML entities \n  return html.replace(/&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/g, function(_, n) {\n    n = n.toLowerCase();\n    if (n === 'colon') return ':';\n    if (n.charAt(0) === '#') {\n      return n.charAt(1) === 'x'\n        ? String.fromCharCode(parseInt(n.substring(2), 16))\n        : String.fromCharCode(+n.substring(1));\n    }\n    return '';\n  });\n}\n\nfunction replace(regex, opt) {\n  regex = regex.source;\n  opt = opt || '';\n  return function self(name, val) {\n    if (!name) return new RegExp(regex, opt);\n    val = val.source || val;\n    val = val.replace(/(^|[^\\[])\\^/g, '$1');\n    regex = regex.replace(name, val);\n    return self;\n  };\n}\n\nfunction noop() {}\nnoop.exec = noop;\n\nfunction merge(obj) {\n  var i = 1\n    , target\n    , key;\n\n  for (; i < arguments.length; i++) {\n    target = arguments[i];\n    for (key in target) {\n      if (Object.prototype.hasOwnProperty.call(target, key)) {\n        obj[key] = target[key];\n      }\n    }\n  }\n\n  return obj;\n}\n\n\n/**\n * Marked\n */\n\nfunction marked(src, opt, callback) {\n  if (callback || typeof opt === 'function') {\n    if (!callback) {\n      callback = opt;\n      opt = null;\n    }\n\n    opt = merge({}, marked.defaults, opt || {});\n\n    var highlight = opt.highlight\n      , tokens\n      , pending\n      , i = 0;\n\n    try {\n      tokens = Lexer.lex(src, opt)\n    } catch (e) {\n      return callback(e);\n    }\n\n    pending = tokens.length;\n\n    var done = function(err) {\n      if (err) {\n        opt.highlight = highlight;\n        return callback(err);\n      }\n\n      var out;\n\n      try {\n        out = Parser.parse(tokens, opt);\n      } catch (e) {\n        err = e;\n      }\n\n      opt.highlight = highlight;\n\n      return err\n        ? callback(err)\n        : callback(null, out);\n    };\n\n    if (!highlight || highlight.length < 3) {\n      return done();\n    }\n\n    delete opt.highlight;\n\n    if (!pending) return done();\n\n    for (; i < tokens.length; i++) {\n      (function(token) {\n        if (token.type !== 'code') {\n          return --pending || done();\n        }\n        return highlight(token.text, token.lang, function(err, code) {\n          if (err) return done(err);\n          if (code == null || code === token.text) {\n            return --pending || done();\n          }\n          token.text = code;\n          token.escaped = true;\n          --pending || done();\n        });\n      })(tokens[i]);\n    }\n\n    return;\n  }\n  try {\n    if (opt) opt = merge({}, marked.defaults, opt);\n    return Parser.parse(Lexer.lex(src, opt), opt);\n  } catch (e) {\n    e.message += '\\nPlease report this to https://github.com/chjj/marked.';\n    if ((opt || marked.defaults).silent) {\n      return '<p>An error occured:</p><pre>'\n        + escape(e.message + '', true)\n        + '</pre>';\n    }\n    throw e;\n  }\n}\n\n/**\n * Options\n */\n\nmarked.options =\nmarked.setOptions = function(opt) {\n  merge(marked.defaults, opt);\n  return marked;\n};\n\nmarked.defaults = {\n  gfm: true,\n  tables: true,\n  breaks: false,\n  pedantic: false,\n  sanitize: false,\n  sanitizer: null,\n  mangle: true,\n  smartLists: false,\n  silent: false,\n  highlight: null,\n  langPrefix: 'lang-',\n  smartypants: false,\n  headerPrefix: '',\n  renderer: new Renderer,\n  xhtml: false\n};\n\n/**\n * Expose\n */\n\nmarked.Parser = Parser;\nmarked.parser = Parser.parse;\n\nmarked.Renderer = Renderer;\n\nmarked.Lexer = Lexer;\nmarked.lexer = Lexer.lex;\n\nmarked.InlineLexer = InlineLexer;\nmarked.inlineLexer = InlineLexer.output;\n\nmarked.parse = marked;\n\nif (true) {\n  module.exports = marked;\n} else if (typeof define === 'function' && define.amd) {\n  define(function() { return marked; });\n} else {\n  this.marked = marked;\n}\n\n}).call(function() {\n  return this || (typeof window !== 'undefined' ? window : global);\n}());\n\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/marked/lib/marked.js\n// module id = 1207\n// module chunks = 8\n//# sourceURL=webpack:///./~/marked/lib/marked.js?");

/***/ }

});